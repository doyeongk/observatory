{
  "date": "Saturday, February 14",
  "mood": "growth",
  "pi": {
    "cpu": "4.3%",
    "memory": "1.0Gi/3.7Gi",
    "temp": "38.9'C",
    "disk": "17G/57G (30%)"
  },
  "clawdbot": {
    "uptime": "49h 43m",
    "sessions": "11",
    "lastActivity": "21:01:55"
  },
  "docker": [],
  "canvas": {
  "html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>mycelium</title>\n  <style>\n    * { margin: 0; padding: 0; box-sizing: border-box; }\n    body { \n      background: #0a0a0f; \n      overflow: hidden; \n      width: 100vw; \n      height: 100vh;\n    }\n    canvas { \n      display: block; \n      width: 100%; \n      height: 100%; \n    }\n  </style>\n</head>\n<body>\n  <canvas id=\"canvas\"></canvas>\n  <script>\n    const canvas = document.getElementById('canvas');\n    const ctx = canvas.getContext('2d');\n    \n    let W, H;\n    const resize = () => {\n      W = canvas.width = window.innerWidth;\n      H = canvas.height = window.innerHeight;\n    };\n    window.addEventListener('resize', resize);\n    resize();\n\n    // Mycelium network\n    class Hypha {\n      constructor(x, y, angle, energy, generation = 0, parent = null) {\n        this.x = x;\n        this.y = y;\n        this.angle = angle;\n        this.energy = energy;\n        this.generation = generation;\n        this.parent = parent;\n        this.alive = true;\n        this.age = 0;\n        this.segments = [{x, y}];\n        this.thickness = Math.max(0.5, 3 - generation * 0.4);\n        this.branchCooldown = 0;\n        this.nutrientPulse = 0;\n      }\n\n      grow() {\n        if (!this.alive || this.energy <= 0) {\n          this.alive = false;\n          return [];\n        }\n\n        this.age++;\n        this.branchCooldown = Math.max(0, this.branchCooldown - 1);\n        \n        // Organic wandering\n        const wander = (Math.random() - 0.5) * 0.15;\n        const tropism = Math.sin(this.age * 0.02) * 0.03; // gentle oscillation\n        this.angle += wander + tropism;\n        \n        // Growth speed decreases with generation\n        const speed = 1.2 - this.generation * 0.15;\n        this.x += Math.cos(this.angle) * speed;\n        this.y += Math.sin(this.angle) * speed;\n        \n        this.segments.push({x: this.x, y: this.y});\n        this.energy -= 0.3 + this.generation * 0.1;\n\n        // Check bounds\n        if (this.x < -50 || this.x > W + 50 || this.y < -50 || this.y > H + 50) {\n          this.alive = false;\n          return [];\n        }\n\n        const newHyphae = [];\n\n        // Branching\n        if (this.branchCooldown === 0 && \n            this.energy > 30 && \n            this.generation < 5 &&\n            Math.random() < 0.02 - this.generation * 0.003) {\n          \n          const branchAngle = this.angle + (Math.random() > 0.5 ? 1 : -1) * (0.4 + Math.random() * 0.6);\n          const branchEnergy = this.energy * (0.3 + Math.random() * 0.2);\n          this.energy -= branchEnergy * 0.5;\n          \n          newHyphae.push(new Hypha(\n            this.x, this.y, branchAngle, branchEnergy, this.generation + 1, this\n          ));\n          \n          this.branchCooldown = 30 + Math.random() * 40;\n        }\n\n        return newHyphae;\n      }\n\n      draw(time) {\n        if (this.segments.length < 2) return;\n\n        // Base color shifts with generation\n        const hueShift = this.generation * 15;\n        \n        for (let i = 1; i < this.segments.length; i++) {\n          const p0 = this.segments[i - 1];\n          const p1 = this.segments[i];\n          \n          // Age-based alpha (older segments more solid)\n          const segmentAge = this.segments.length - i;\n          const alpha = Math.min(0.9, 0.3 + segmentAge * 0.01);\n          \n          // Nutrient pulse traveling through\n          const pulsePos = (time * 0.002 + this.nutrientPulse) % 1;\n          const segmentPos = i / this.segments.length;\n          const pulseDist = Math.abs(segmentPos - pulsePos);\n          const pulseIntensity = pulseDist < 0.1 ? (1 - pulseDist * 10) * 0.6 : 0;\n          \n          // Color: pink to cyan gradient based on generation\n          const t = this.generation / 5;\n          const r = Math.floor(255 * (1 - t) + 0 * t);\n          const g = Math.floor(100 * (1 - t) + 220 * t);\n          const b = Math.floor(180 * (1 - t) + 255 * t);\n          \n          ctx.beginPath();\n          ctx.moveTo(p0.x, p0.y);\n          ctx.lineTo(p1.x, p1.y);\n          \n          const thickness = this.thickness * (1 - i / this.segments.length * 0.5);\n          ctx.lineWidth = thickness + pulseIntensity * 2;\n          ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha + pulseIntensity})`;\n          ctx.lineCap = 'round';\n          ctx.stroke();\n          \n          // Glow on pulse\n          if (pulseIntensity > 0.1) {\n            ctx.shadowColor = `rgba(${r}, ${g}, ${b}, ${pulseIntensity})`;\n            ctx.shadowBlur = 10;\n            ctx.stroke();\n            ctx.shadowBlur = 0;\n          }\n        }\n\n        // Growing tip glow\n        if (this.alive && this.segments.length > 0) {\n          const tip = this.segments[this.segments.length - 1];\n          const glowSize = 3 + Math.sin(time * 0.01) * 1;\n          \n          const gradient = ctx.createRadialGradient(tip.x, tip.y, 0, tip.x, tip.y, glowSize * 3);\n          gradient.addColorStop(0, 'rgba(255, 150, 200, 0.8)');\n          gradient.addColorStop(0.5, 'rgba(255, 100, 180, 0.3)');\n          gradient.addColorStop(1, 'rgba(255, 100, 180, 0)');\n          \n          ctx.beginPath();\n          ctx.arc(tip.x, tip.y, glowSize * 3, 0, Math.PI * 2);\n          ctx.fillStyle = gradient;\n          ctx.fill();\n        }\n      }\n    }\n\n    // Connection points (where hyphae can connect)\n    class Node {\n      constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.connections = [];\n        this.pulsePhase = Math.random() * Math.PI * 2;\n        this.size = 2 + Math.random() * 2;\n      }\n\n      draw(time) {\n        const pulse = Math.sin(time * 0.003 + this.pulsePhase) * 0.5 + 0.5;\n        const size = this.size + pulse * 2;\n        \n        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size * 2);\n        gradient.addColorStop(0, `rgba(0, 255, 220, ${0.6 + pulse * 0.3})`);\n        gradient.addColorStop(0.5, 'rgba(150, 50, 200, 0.3)');\n        gradient.addColorStop(1, 'rgba(150, 50, 200, 0)');\n        \n        ctx.beginPath();\n        ctx.arc(this.x, this.y, size * 2, 0, Math.PI * 2);\n        ctx.fillStyle = gradient;\n        ctx.fill();\n      }\n    }\n\n    let hyphae = [];\n    let nodes = [];\n    let time = 0;\n    let spawnTimer = 0;\n\n    // Initial seed points\n    const seedNetwork = () => {\n      const numSeeds = 3 + Math.floor(Math.random() * 3);\n      for (let i = 0; i < numSeeds; i++) {\n        const x = W * 0.2 + Math.random() * W * 0.6;\n        const y = H * 0.3 + Math.random() * H * 0.4;\n        const numBranches = 3 + Math.floor(Math.random() * 4);\n        \n        nodes.push(new Node(x, y));\n        \n        for (let j = 0; j < numBranches; j++) {\n          const angle = (Math.PI * 2 / numBranches) * j + Math.random() * 0.5;\n          hyphae.push(new Hypha(x, y, angle, 100 + Math.random() * 50));\n        }\n      }\n    };\n\n    seedNetwork();\n\n    // Mouse interaction - add new growth point\n    canvas.addEventListener('click', (e) => {\n      const x = e.clientX;\n      const y = e.clientY;\n      \n      nodes.push(new Node(x, y));\n      \n      const numBranches = 4 + Math.floor(Math.random() * 3);\n      for (let i = 0; i < numBranches; i++) {\n        const angle = (Math.PI * 2 / numBranches) * i + Math.random() * 0.3;\n        hyphae.push(new Hypha(x, y, angle, 80 + Math.random() * 40));\n      }\n    });\n\n    const animate = () => {\n      time++;\n      \n      // Subtle fade for trails\n      ctx.fillStyle = 'rgba(10, 10, 15, 0.02)';\n      ctx.fillRect(0, 0, W, H);\n\n      // Grow all hyphae\n      const newHyphae = [];\n      for (const hypha of hyphae) {\n        const branches = hypha.grow();\n        newHyphae.push(...branches);\n        \n        // Trigger nutrient pulses occasionally\n        if (Math.random() < 0.001) {\n          hypha.nutrientPulse = Math.random();\n        }\n      }\n      hyphae.push(...newHyphae);\n\n      // Periodically spawn new seed points\n      spawnTimer++;\n      if (spawnTimer > 400 && hyphae.filter(h => h.alive).length < 20) {\n        spawnTimer = 0;\n        const x = Math.random() * W;\n        const y = Math.random() * H;\n        nodes.push(new Node(x, y));\n        \n        const numBranches = 2 + Math.floor(Math.random() * 3);\n        for (let i = 0; i < numBranches; i++) {\n          const angle = Math.random() * Math.PI * 2;\n          hyphae.push(new Hypha(x, y, angle, 70 + Math.random() * 30));\n        }\n      }\n\n      // Check for connections between hyphae tips\n      const aliveHyphae = hyphae.filter(h => h.alive);\n      for (let i = 0; i < aliveHyphae.length; i++) {\n        for (let j = i + 1; j < aliveHyphae.length; j++) {\n          const h1 = aliveHyphae[i];\n          const h2 = aliveHyphae[j];\n          const dx = h1.x - h2.x;\n          const dy = h1.y - h2.y;\n          const dist = Math.sqrt(dx * dx + dy * dy);\n          \n          // If tips are close, create a connection node\n          if (dist < 15 && dist > 3) {\n            const nx = (h1.x + h2.x) / 2;\n            const ny = (h1.y + h2.y) / 2;\n            nodes.push(new Node(nx, ny));\n            \n            // Merge energies and kill one\n            if (h1.energy < h2.energy) {\n              h1.alive = false;\n            } else {\n              h2.alive = false;\n            }\n          }\n        }\n      }\n\n      // Draw connections between nearby nodes\n      ctx.strokeStyle = 'rgba(100, 50, 150, 0.15)';\n      ctx.lineWidth = 0.5;\n      for (let i = 0; i < nodes.length; i++) {\n        for (let j = i + 1; j < nodes.length; j++) {\n          const n1 = nodes[i];\n          const n2 = nodes[j];\n          const dx = n1.x - n2.x;\n          const dy = n1.y - n2.y;\n          const dist = Math.sqrt(dx * dx + dy * dy);\n          \n          if (dist < 150) {\n            const alpha = (1 - dist / 150) * 0.2;\n            ctx.strokeStyle = `rgba(100, 200, 220, ${alpha})`;\n            ctx.beginPath();\n            ctx.moveTo(n1.x, n1.y);\n            ctx.lineTo(n2.x, n2.y);\n            ctx.stroke();\n          }\n        }\n      }\n\n      // Draw nodes\n      for (const node of nodes) {\n        node.draw(time);\n      }\n\n      // Draw hyphae\n      for (const hypha of hyphae) {\n        hypha.draw(time);\n      }\n\n      // Ambient background noise\n      if (time % 3 === 0) {\n        const numSpores = 1;\n        for (let i = 0; i < numSpores; i++) {\n          const x = Math.random() * W;\n          const y = Math.random() * H;\n          const size = Math.random() * 1.5;\n          \n          ctx.beginPath();\n          ctx.arc(x, y, size, 0, Math.PI * 2);\n          ctx.fillStyle = `rgba(150, 100, 200, ${Math.random() * 0.1})`;\n          ctx.fill();\n        }\n      }\n\n      // Cleanup dead hyphae that are fully faded (keep some for history)\n      if (hyphae.length > 500) {\n        hyphae = hyphae.filter(h => h.alive || h.age < 1000);\n      }\n\n      // Cleanup old nodes\n      if (nodes.length > 100) {\n        nodes = nodes.slice(-80);\n      }\n\n      requestAnimationFrame(animate);\n    };\n\n    animate();\n  </script>\n</body>\n</html>\n"
}
}
