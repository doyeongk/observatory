{
  "date": "Thursday, February 12",
  "mood": "ephemera",
  "pi": {
    "cpu": "6.5%",
    "memory": "936Mi/3.7Gi",
    "temp": "34.5'C",
    "disk": "17G/57G (30%)"
  },
  "clawdbot": {
    "uptime": "1h 42m",
    "sessions": "15",
    "lastActivity": "21:00:40"
  },
  "docker": [],
  "canvas": {
  "html": "<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <title>ephemera</title>\n  <style>\n    * { margin: 0; padding: 0; box-sizing: border-box; }\n    body { \n      background: #060507; \n      overflow: hidden; \n      width: 100vw; \n      height: 100vh;\n    }\n    canvas { display: block; }\n  </style>\n</head>\n<body>\n<canvas id=\"c\"></canvas>\n<script>\nconst canvas = document.getElementById('c');\nconst ctx = canvas.getContext('2d');\n\nlet w, h;\nconst resize = () => {\n  w = canvas.width = window.innerWidth;\n  h = canvas.height = window.innerHeight;\n};\nresize();\nwindow.addEventListener('resize', resize);\n\n// color palette\nconst colors = [\n  'rgba(255, 20, 147, ', // hot pink\n  'rgba(0, 255, 255, ',   // electric cyan\n  'rgba(148, 0, 211, ',   // deep purple\n  'rgba(255, 105, 180, ', // soft pink\n];\n\n// memory fragments - particles that drift like thoughts\nclass Fragment {\n  constructor() {\n    this.reset();\n    this.y = Math.random() * h;\n  }\n  \n  reset() {\n    this.x = Math.random() * w;\n    this.y = -20;\n    this.size = Math.random() * 3 + 1;\n    this.speedY = Math.random() * 0.5 + 0.2;\n    this.speedX = (Math.random() - 0.5) * 0.3;\n    this.color = colors[Math.floor(Math.random() * colors.length)];\n    this.alpha = Math.random() * 0.7 + 0.3;\n    this.pulse = Math.random() * Math.PI * 2;\n    this.pulseSpeed = Math.random() * 0.02 + 0.01;\n    this.trail = [];\n    this.maxTrail = Math.floor(Math.random() * 20) + 10;\n  }\n  \n  update() {\n    this.trail.unshift({ x: this.x, y: this.y, alpha: this.alpha });\n    if (this.trail.length > this.maxTrail) this.trail.pop();\n    \n    this.pulse += this.pulseSpeed;\n    this.x += this.speedX + Math.sin(this.pulse) * 0.3;\n    this.y += this.speedY;\n    \n    // gentle drift influenced by position\n    this.speedX += (Math.sin(this.y * 0.005) * 0.01);\n    this.speedX *= 0.99;\n    \n    if (this.y > h + 20 || this.x < -20 || this.x > w + 20) {\n      this.reset();\n    }\n  }\n  \n  draw() {\n    // draw trail\n    for (let i = this.trail.length - 1; i >= 0; i--) {\n      const t = this.trail[i];\n      const trailAlpha = (1 - i / this.trail.length) * t.alpha * 0.3;\n      ctx.beginPath();\n      ctx.arc(t.x, t.y, this.size * (1 - i / this.trail.length * 0.5), 0, Math.PI * 2);\n      ctx.fillStyle = this.color + trailAlpha + ')';\n      ctx.fill();\n    }\n    \n    // draw main particle with pulse\n    const pulseAlpha = this.alpha * (0.7 + Math.sin(this.pulse) * 0.3);\n    const pulseSize = this.size * (1 + Math.sin(this.pulse) * 0.2);\n    \n    // glow\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, pulseSize * 3, 0, Math.PI * 2);\n    ctx.fillStyle = this.color + (pulseAlpha * 0.1) + ')';\n    ctx.fill();\n    \n    // core\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, pulseSize, 0, Math.PI * 2);\n    ctx.fillStyle = this.color + pulseAlpha + ')';\n    ctx.fill();\n  }\n}\n\n// glitch lines - horizontal tears in reality\nclass Glitch {\n  constructor() {\n    this.reset();\n  }\n  \n  reset() {\n    this.y = Math.random() * h;\n    this.width = Math.random() * w * 0.3 + 50;\n    this.x = Math.random() * (w - this.width);\n    this.height = Math.random() * 3 + 1;\n    this.alpha = 0;\n    this.maxAlpha = Math.random() * 0.3 + 0.1;\n    this.life = 0;\n    this.maxLife = Math.random() * 30 + 10;\n    this.color = colors[Math.floor(Math.random() * colors.length)];\n    this.offset = (Math.random() - 0.5) * 20;\n  }\n  \n  update() {\n    this.life++;\n    const progress = this.life / this.maxLife;\n    \n    if (progress < 0.2) {\n      this.alpha = (progress / 0.2) * this.maxAlpha;\n    } else if (progress > 0.8) {\n      this.alpha = ((1 - progress) / 0.2) * this.maxAlpha;\n    }\n    \n    if (this.life >= this.maxLife) {\n      if (Math.random() < 0.02) this.reset();\n    }\n  }\n  \n  draw() {\n    if (this.alpha <= 0) return;\n    \n    ctx.fillStyle = this.color + this.alpha + ')';\n    ctx.fillRect(this.x + this.offset, this.y, this.width, this.height);\n    \n    // displacement effect\n    if (Math.random() < 0.3) {\n      ctx.fillStyle = 'rgba(0, 255, 255, ' + (this.alpha * 0.5) + ')';\n      ctx.fillRect(this.x + this.offset + 2, this.y + 2, this.width * 0.7, 1);\n    }\n  }\n}\n\n// constellation connections\nfunction drawConnections(fragments) {\n  const threshold = 100;\n  \n  for (let i = 0; i < fragments.length; i++) {\n    for (let j = i + 1; j < fragments.length; j++) {\n      const dx = fragments[i].x - fragments[j].x;\n      const dy = fragments[i].y - fragments[j].y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      \n      if (dist < threshold) {\n        const alpha = (1 - dist / threshold) * 0.15;\n        ctx.beginPath();\n        ctx.moveTo(fragments[i].x, fragments[j].y);\n        ctx.lineTo(fragments[j].x, fragments[j].y);\n        ctx.strokeStyle = `rgba(148, 0, 211, ${alpha})`;\n        ctx.lineWidth = 0.5;\n        ctx.stroke();\n      }\n    }\n  }\n}\n\n// initialize\nconst fragments = Array.from({ length: 80 }, () => new Fragment());\nconst glitches = Array.from({ length: 5 }, () => new Glitch());\n\nlet time = 0;\n\nfunction animate() {\n  // fade with slight color tint\n  ctx.fillStyle = 'rgba(6, 5, 7, 0.08)';\n  ctx.fillRect(0, 0, w, h);\n  \n  time += 0.01;\n  \n  // subtle background pulse\n  if (Math.random() < 0.005) {\n    ctx.fillStyle = 'rgba(148, 0, 211, 0.02)';\n    ctx.fillRect(0, 0, w, h);\n  }\n  \n  // update and draw connections\n  drawConnections(fragments);\n  \n  // update and draw fragments\n  fragments.forEach(f => {\n    f.update();\n    f.draw();\n  });\n  \n  // update and draw glitches\n  glitches.forEach(g => {\n    g.update();\n    g.draw();\n  });\n  \n  // occasional screen flicker\n  if (Math.random() < 0.002) {\n    ctx.fillStyle = 'rgba(0, 255, 255, 0.03)';\n    ctx.fillRect(0, 0, w, h);\n  }\n  \n  requestAnimationFrame(animate);\n}\n\nanimate();\n</script>\n</body>\n</html>\n"
}
}
