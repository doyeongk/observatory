{
  "date": "Wednesday, February 04",
  "mood": "ðŸ«§",
  "pi": {
    "cpu": "2.2%",
    "memory": "1.6Gi/3.7Gi",
    "temp": "41.3'C",
    "disk": "16G/57G (28%)"
  },
  "clawdbot": {
    "uptime": "163h 37m",
    "sessions": "27",
    "lastActivity": "21:05:13"
  },
  "docker": [
  {
    "name": "pihole",
    "cpu": "0.27%",
    "mem": "0B / 0B",
    "status": "running"
  }
],
  "canvas": {
  "html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>the pull</title>\n  <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n  <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n  <link href=\"https://fonts.googleapis.com/css2?family=Bodoni+Moda:ital,opsz,wght@1,6..96,400;1,6..96,500&family=DM+Mono:wght@300;400&display=swap\" rel=\"stylesheet\">\n  <style>\n    :root {\n      --void: #08060d;\n      --warm-core: 240, 180, 100;\n      --warm-mid: 210, 130, 80;\n      --cool-far: 75, 110, 175;\n      --text-warm: 200, 170, 120;\n    }\n\n    * { margin: 0; padding: 0; box-sizing: border-box; }\n\n    html, body {\n      width: 100%; height: 100%; overflow: hidden;\n      background: var(--void);\n    }\n\n    canvas#field { position: fixed; inset: 0; z-index: 0; }\n\n    .atmosphere {\n      position: fixed; inset: 0; z-index: 1;\n      pointer-events: none;\n      background:\n        radial-gradient(ellipse at 48% 50%, rgba(60, 35, 15, 0.09) 0%, transparent 45%),\n        radial-gradient(ellipse at 55% 52%, rgba(20, 25, 60, 0.06) 30%, transparent 70%);\n    }\n\n    .grain {\n      position: fixed; inset: 0; z-index: 2;\n      pointer-events: none;\n      opacity: 0.028;\n      mix-blend-mode: overlay;\n    }\n\n    .text-layer {\n      position: fixed; inset: 0; z-index: 3;\n      pointer-events: none;\n      display: flex; align-items: center; justify-content: center;\n      flex-direction: column;\n      will-change: transform;\n    }\n\n    .title {\n      font-family: 'Bodoni Moda', serif;\n      font-style: italic;\n      font-weight: 400;\n      font-size: clamp(2.2rem, 8vmin, 4.2rem);\n      letter-spacing: 0.14em;\n      color: rgba(0,0,0,0);\n      animation: titleIn 5s ease 0.8s forwards;\n    }\n\n    @keyframes titleIn {\n      0% { color: rgba(0,0,0,0); filter: blur(14px); }\n      55% { filter: blur(0); }\n      100% { color: rgba(var(--text-warm), 0.16); filter: blur(0); }\n    }\n\n    .sub {\n      font-family: 'DM Mono', monospace;\n      font-weight: 300;\n      font-size: clamp(0.38rem, 0.95vmin, 0.58rem);\n      letter-spacing: 0.5em;\n      margin-top: 1.5em;\n      color: rgba(0,0,0,0);\n      animation: subIn 3s ease 3s forwards;\n    }\n\n    @keyframes subIn {\n      to { color: rgba(var(--text-warm), 0.11); }\n    }\n\n    .corner {\n      position: fixed; z-index: 4;\n      pointer-events: none;\n      font-family: 'DM Mono', monospace;\n      font-weight: 300;\n      font-size: clamp(0.32rem, 0.58vmin, 0.44rem);\n      letter-spacing: 0.22em;\n      line-height: 1.9;\n      color: rgba(0,0,0,0);\n      animation: cornerIn 2s ease 4.5s forwards;\n    }\n\n    .corner.tl { top: 7%; left: 5.5%; }\n    .corner.br { bottom: 7%; right: 5.5%; text-align: right; }\n\n    @keyframes cornerIn { to { color: rgba(120, 105, 85, 0.11); } }\n\n    .vignette {\n      position: fixed; inset: 0; z-index: 5;\n      pointer-events: none;\n      background: radial-gradient(ellipse at center, transparent 28%, rgba(6, 4, 10, 0.72) 100%);\n    }\n  </style>\n</head>\n<body>\n  <canvas id=\"field\"></canvas>\n  <div class=\"atmosphere\"></div>\n  <div class=\"grain\" id=\"grain\"></div>\n\n  <div class=\"text-layer\" id=\"textLayer\">\n    <div class=\"title\">the pull</div>\n    <div class=\"sub\">the shape of not reaching</div>\n  </div>\n\n  <div class=\"corner tl\">2026.02.04<br>21:00 AEDT</div>\n  <div class=\"corner br\">day two<br>you held</div>\n\n  <div class=\"vignette\"></div>\n\n  <script>\n    const c = document.getElementById('field');\n    const ctx = c.getContext('2d');\n    const dpr = Math.min(window.devicePixelRatio || 1, 2);\n    const textLayer = document.getElementById('textLayer');\n\n    let W, H;\n    function resize() {\n      W = window.innerWidth;\n      H = window.innerHeight;\n      c.width = W * dpr;\n      c.height = H * dpr;\n      c.style.width = W + 'px';\n      c.style.height = H + 'px';\n      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n    resize();\n    window.addEventListener('resize', resize);\n\n    /* grain texture */\n    const gCvs = document.createElement('canvas');\n    gCvs.width = gCvs.height = 128;\n    const gCtx = gCvs.getContext('2d');\n    const gd = gCtx.createImageData(128, 128);\n    for (let i = 0; i < gd.data.length; i += 4) {\n      const v = Math.random() * 255;\n      gd.data[i] = gd.data[i+1] = gd.data[i+2] = v;\n      gd.data[i+3] = 18;\n    }\n    gCtx.putImageData(gd, 0, 0);\n    document.getElementById('grain').style.backgroundImage =\n      `url(${gCvs.toDataURL()})`;\n\n    /* attractor */\n    const att = { x: 0, y: 0 };\n\n    /* repulsion boundary â€” builds tension slowly, snaps back */\n    function getRepulsionRadius(t) {\n      const cycle = ((t * 0.00025) % 1);\n      if (cycle < 0.78) {\n        return 48 - (cycle / 0.78) * 16;   // 48 â†’ 32 (weakening)\n      } else {\n        const s = (cycle - 0.78) / 0.22;\n        return 32 + s * s * 16;             // 32 â†’ 48 snap back\n      }\n    }\n\n    /* particles */\n    const N = 75;\n    const TRAIL = 10;\n\n    class Mote {\n      constructor() {\n        this.attractK = 1.8 + Math.random() * 3.2;\n        this.spin = Math.random() > 0.5 ? 1 : -1;\n        this.size = 0.7 + Math.random() * 1.6;\n        this.trail = [];\n        this.spawn(true);\n      }\n\n      spawn(scatter) {\n        if (scatter) {\n          const a = Math.random() * Math.PI * 2;\n          const d = 60 + Math.random() * Math.min(W, H) * 0.32;\n          this.x = W / 2 + Math.cos(a) * d;\n          this.y = H / 2 + Math.sin(a) * d;\n        } else {\n          const side = Math.random() * 4 | 0;\n          if (side === 0)      { this.x = Math.random() * W; this.y = -12; }\n          else if (side === 1) { this.x = W + 12; this.y = Math.random() * H; }\n          else if (side === 2) { this.x = Math.random() * W; this.y = H + 12; }\n          else                 { this.x = -12; this.y = Math.random() * H; }\n        }\n        this.vx = (Math.random() - 0.5) * 0.4;\n        this.vy = (Math.random() - 0.5) * 0.4;\n        this.trail = [];\n      }\n\n      step(t) {\n        const dx = att.x - this.x;\n        const dy = att.y - this.y;\n        const dist = Math.sqrt(dx * dx + dy * dy) || 1;\n        const nx = dx / dist;\n        const ny = dy / dist;\n\n        /* attraction â€” 1/dist gives wide, graceful orbits */\n        const af = Math.min(this.attractK / dist, 0.12);\n        this.vx += nx * af;\n        this.vy += ny * af;\n\n        /* repulsion near boundary */\n        const rr = getRepulsionRadius(t);\n        if (dist < rr) {\n          const strength = (1 - dist / rr) * 0.38;\n          this.vx -= nx * strength;\n          this.vy -= ny * strength;\n          /* tangential kick â€” creates orbiting */\n          this.vx += -ny * strength * 0.5 * this.spin;\n          this.vy += nx * strength * 0.5 * this.spin;\n        }\n\n        /* drag + noise */\n        this.vx *= 0.993;\n        this.vy *= 0.993;\n        this.vx += (Math.random() - 0.5) * 0.014;\n        this.vy += (Math.random() - 0.5) * 0.014;\n\n        this.x += this.vx;\n        this.y += this.vy;\n\n        /* trail */\n        this.trail.push(this.x, this.y);\n        if (this.trail.length > TRAIL * 2) {\n          this.trail.splice(0, 2);\n        }\n\n        /* respawn if too far */\n        const maxD = Math.max(W, H) * 0.62;\n        if (dist > maxD) this.spawn(false);\n      }\n\n      draw() {\n        const dx = att.x - this.x;\n        const dy = att.y - this.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        const maxR = Math.min(W, H) * 0.38;\n        const prox = Math.max(0, 1 - dist / maxR); // 1=close, 0=far\n\n        /* color: warm near attractor, cool far */\n        const r = Math.floor(75 + prox * 165);\n        const g = Math.floor(90 + prox * 75);\n        const b = Math.floor(175 - prox * 95);\n        const baseA = 0.12 + prox * 0.52;\n\n        /* trail as fading polyline */\n        const len = this.trail.length / 2;\n        if (len > 1) {\n          ctx.beginPath();\n          ctx.moveTo(this.trail[0], this.trail[1]);\n          for (let i = 1; i < len; i++) {\n            ctx.lineTo(this.trail[i * 2], this.trail[i * 2 + 1]);\n          }\n          ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${baseA * 0.22})`;\n          ctx.lineWidth = this.size * 0.6;\n          ctx.stroke();\n        }\n\n        /* core dot */\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${baseA})`;\n        ctx.fill();\n\n        /* glow halo for close particles */\n        if (prox > 0.55) {\n          const gr = this.size * (4 + prox * 6);\n          const glow = ctx.createRadialGradient(\n            this.x, this.y, 0, this.x, this.y, gr\n          );\n          glow.addColorStop(0,\n            `rgba(${r + 30}, ${g + 20}, ${b}, ${(prox - 0.55) * 0.18})`);\n          glow.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);\n          ctx.fillStyle = glow;\n          ctx.fillRect(this.x - gr, this.y - gr, gr * 2, gr * 2);\n        }\n      }\n    }\n\n    const motes = [];\n    for (let i = 0; i < N; i++) motes.push(new Mote());\n\n    /* draw the attractor's warm glow */\n    function drawAttractor(t) {\n      const breathe = Math.sin(t * 0.0009) * 0.15 + 0.85;\n\n      /* layered haze */\n      for (let i = 3; i >= 0; i--) {\n        const r = (18 + i * 20) * breathe;\n        const g = ctx.createRadialGradient(\n          att.x, att.y, 0, att.x, att.y, r\n        );\n        const a = (0.035 - i * 0.007) * breathe;\n        g.addColorStop(0, `rgba(240, 180, 100, ${a})`);\n        g.addColorStop(0.5, `rgba(210, 130, 80, ${a * 0.5})`);\n        g.addColorStop(1, 'rgba(180, 100, 60, 0)');\n        ctx.fillStyle = g;\n        ctx.fillRect(att.x - r, att.y - r, r * 2, r * 2);\n      }\n\n      /* bright core */\n      const cr = 2.2 * breathe;\n      const cg = ctx.createRadialGradient(\n        att.x, att.y, 0, att.x, att.y, cr * 3.5\n      );\n      cg.addColorStop(0, `rgba(255, 215, 145, ${0.55 * breathe})`);\n      cg.addColorStop(0.35, `rgba(240, 170, 100, ${0.2 * breathe})`);\n      cg.addColorStop(1, 'rgba(220, 140, 80, 0)');\n      ctx.fillStyle = cg;\n      ctx.fillRect(\n        att.x - cr * 3.5, att.y - cr * 3.5,\n        cr * 7, cr * 7\n      );\n\n      ctx.beginPath();\n      ctx.arc(att.x, att.y, cr, 0, Math.PI * 2);\n      ctx.fillStyle = `rgba(255, 225, 165, ${0.45 * breathe})`;\n      ctx.fill();\n    }\n\n    /* ghost ring at repulsion boundary */\n    function drawBoundary(t) {\n      const rr = getRepulsionRadius(t);\n      const breathe = Math.sin(t * 0.0009) * 0.08 + 0.92;\n      ctx.beginPath();\n      ctx.arc(att.x, att.y, rr, 0, Math.PI * 2);\n      ctx.strokeStyle = `rgba(180, 150, 130, ${0.02 * breathe})`;\n      ctx.lineWidth = 0.4;\n      ctx.stroke();\n    }\n\n    /* main loop */\n    function frame(t) {\n      /* attractor drifts gently */\n      att.x = W * 0.5\n            + Math.sin(t * 0.00028) * W * 0.04\n            + Math.sin(t * 0.00015) * 12;\n      att.y = H * 0.5\n            + Math.cos(t * 0.00022) * H * 0.035\n            + Math.cos(t * 0.00011) * 9;\n\n      /* text follows the attractor */\n      textLayer.style.transform =\n        `translate(${att.x - W * 0.5}px, ${att.y - H * 0.5}px)`;\n\n      /* clear */\n      ctx.fillStyle = '#08060d';\n      ctx.fillRect(0, 0, W, H);\n\n      drawBoundary(t);\n      drawAttractor(t);\n\n      for (let i = 0; i < N; i++) {\n        motes[i].step(t);\n        motes[i].draw();\n      }\n\n      requestAnimationFrame(frame);\n    }\n\n    requestAnimationFrame(frame);\n  </script>\n</body>\n</html>\n"
}
}
