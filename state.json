{
  "date": "Sunday, February 15",
  "mood": "hypnotic",
  "pi": {
    "cpu": "4.4%",
    "memory": "1.1Gi/3.7Gi",
    "temp": "39.4'C",
    "disk": "17G/57G (30%)"
  },
  "clawdbot": {
    "uptime": "73h 42m",
    "sessions": "15",
    "lastActivity": "21:01:04"
  },
  "docker": [],
  "canvas": {
  "html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<title>interference</title>\n<style>\n* { margin: 0; padding: 0; box-sizing: border-box; }\nbody { \n  background: #0a0a0f; \n  overflow: hidden; \n  cursor: crosshair;\n}\ncanvas { display: block; }\n</style>\n</head>\n<body>\n<canvas id=\"c\"></canvas>\n<script>\nconst canvas = document.getElementById('c');\nconst ctx = canvas.getContext('2d');\n\nlet w, h, cx, cy;\nlet mouseX, mouseY;\nlet time = 0;\n\n// Pattern centers - they drift slowly\nlet centers = [\n  { x: 0.3, y: 0.4, vx: 0.0001, vy: 0.00015, phase: 0 },\n  { x: 0.7, y: 0.6, vx: -0.00012, vy: 0.0001, phase: Math.PI * 0.5 },\n  { x: 0.5, y: 0.3, vx: 0.00008, vy: -0.00013, phase: Math.PI }\n];\n\nfunction resize() {\n  w = canvas.width = window.innerWidth;\n  h = canvas.height = window.innerHeight;\n  cx = w / 2;\n  cy = h / 2;\n  mouseX = cx;\n  mouseY = cy;\n}\n\nwindow.addEventListener('resize', resize);\ncanvas.addEventListener('mousemove', e => {\n  mouseX = e.clientX;\n  mouseY = e.clientY;\n});\ncanvas.addEventListener('touchmove', e => {\n  e.preventDefault();\n  mouseX = e.touches[0].clientX;\n  mouseY = e.touches[0].clientY;\n}, { passive: false });\n\nresize();\n\nfunction drawConcentricRings(centerX, centerY, rotation, lineCount, color, alpha) {\n  ctx.save();\n  ctx.translate(centerX, centerY);\n  ctx.rotate(rotation);\n  \n  const maxRadius = Math.sqrt(w * w + h * h);\n  const spacing = 12;\n  \n  ctx.strokeStyle = color;\n  ctx.lineWidth = 2;\n  ctx.globalAlpha = alpha;\n  \n  for (let r = spacing; r < maxRadius; r += spacing) {\n    ctx.beginPath();\n    ctx.arc(0, 0, r, 0, Math.PI * 2);\n    ctx.stroke();\n  }\n  \n  ctx.restore();\n}\n\nfunction drawRadialLines(centerX, centerY, rotation, lineCount, color, alpha) {\n  ctx.save();\n  ctx.translate(centerX, centerY);\n  ctx.rotate(rotation);\n  \n  const maxRadius = Math.sqrt(w * w + h * h);\n  \n  ctx.strokeStyle = color;\n  ctx.lineWidth = 1.5;\n  ctx.globalAlpha = alpha;\n  \n  for (let i = 0; i < lineCount; i++) {\n    const angle = (i / lineCount) * Math.PI * 2;\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(Math.cos(angle) * maxRadius, Math.sin(angle) * maxRadius);\n    ctx.stroke();\n  }\n  \n  ctx.restore();\n}\n\nfunction drawParallelLines(centerX, centerY, rotation, spacing, color, alpha) {\n  ctx.save();\n  ctx.translate(centerX, centerY);\n  ctx.rotate(rotation);\n  \n  const maxDist = Math.sqrt(w * w + h * h);\n  \n  ctx.strokeStyle = color;\n  ctx.lineWidth = 1.5;\n  ctx.globalAlpha = alpha;\n  \n  for (let d = -maxDist; d < maxDist; d += spacing) {\n    ctx.beginPath();\n    ctx.moveTo(d, -maxDist);\n    ctx.lineTo(d, maxDist);\n    ctx.stroke();\n  }\n  \n  ctx.restore();\n}\n\nfunction animate() {\n  // Fade trail\n  ctx.fillStyle = 'rgba(10, 10, 15, 0.15)';\n  ctx.fillRect(0, 0, w, h);\n  \n  time += 0.003;\n  \n  // Update drifting centers\n  centers.forEach((c, i) => {\n    c.x += c.vx;\n    c.y += c.vy;\n    \n    // Bounce off edges\n    if (c.x < 0.1 || c.x > 0.9) c.vx *= -1;\n    if (c.y < 0.1 || c.y > 0.9) c.vy *= -1;\n  });\n  \n  // Mouse influence on one center\n  const mouseInfluence = 0.05;\n  centers[0].x += (mouseX / w - centers[0].x) * mouseInfluence;\n  centers[0].y += (mouseY / h - centers[0].y) * mouseInfluence;\n  \n  // Pattern 1: Cyan concentric rings, slowly rotating\n  drawConcentricRings(\n    centers[0].x * w,\n    centers[0].y * h,\n    time * 0.3,\n    60,\n    '#00ffff',\n    0.4\n  );\n  \n  // Pattern 2: Magenta concentric rings, counter-rotating\n  drawConcentricRings(\n    centers[1].x * w,\n    centers[1].y * h,\n    -time * 0.25 + 0.02,\n    60,\n    '#ff00ff',\n    0.35\n  );\n  \n  // Pattern 3: Parallel lines, slowly rotating\n  const breathe = Math.sin(time * 0.5) * 3;\n  drawParallelLines(\n    centers[2].x * w,\n    centers[2].y * h,\n    time * 0.15 + Math.PI / 4,\n    10 + breathe,\n    '#9933ff',\n    0.3\n  );\n  \n  // Pattern 4: Radial lines from mouse position\n  drawRadialLines(\n    mouseX,\n    mouseY,\n    time * 0.1,\n    72,\n    '#ff66aa',\n    0.25\n  );\n  \n  // Subtle vignette\n  const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(w, h) * 0.7);\n  gradient.addColorStop(0, 'rgba(10, 10, 15, 0)');\n  gradient.addColorStop(1, 'rgba(10, 10, 15, 0.6)');\n  ctx.fillStyle = gradient;\n  ctx.fillRect(0, 0, w, h);\n  \n  requestAnimationFrame(animate);\n}\n\nanimate();\n</script>\n</body>\n</html>\n"
}
}
