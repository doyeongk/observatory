{
  "date": "Sunday, February 08",
  "mood": "haunted",
  "pi": {
    "cpu": "0.0%",
    "memory": "1.0Gi/3.7Gi",
    "temp": "37.9'C",
    "disk": "16G/57G (30%)"
  },
  "clawdbot": {
    "uptime": "3h 24m",
    "sessions": "17",
    "lastActivity": "21:00:58"
  },
  "docker": [],
  "canvas": {
  "html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>ghosts in the static</title>\n  <style>\n    * { margin: 0; padding: 0; box-sizing: border-box; }\n    body { \n      background: #060507; \n      overflow: hidden; \n      width: 100vw; \n      height: 100vh;\n    }\n    canvas { display: block; }\n  </style>\n</head>\n<body>\n  <canvas id=\"canvas\"></canvas>\n  <script>\n    const canvas = document.getElementById('canvas');\n    const ctx = canvas.getContext('2d');\n    \n    let w, h;\n    const resize = () => {\n      w = canvas.width = window.innerWidth;\n      h = canvas.height = window.innerHeight;\n    };\n    resize();\n    window.addEventListener('resize', resize);\n    \n    // Color palette\n    const colors = {\n      bg: '#060507',\n      purple: '#2d1b4e',\n      pink: '#ff2d95',\n      cyan: '#00f5ff',\n      magenta: '#9d00ff'\n    };\n    \n    // Ghost particles - little spirits drifting through the void\n    class Ghost {\n      constructor() {\n        this.reset();\n        this.y = Math.random() * h;\n      }\n      \n      reset() {\n        this.x = Math.random() * w;\n        this.y = h + 20;\n        this.size = Math.random() * 3 + 1;\n        this.speedY = Math.random() * 0.8 + 0.3;\n        this.wobbleSpeed = Math.random() * 0.02 + 0.01;\n        this.wobbleAmount = Math.random() * 30 + 10;\n        this.phase = Math.random() * Math.PI * 2;\n        this.alpha = Math.random() * 0.5 + 0.3;\n        this.color = Math.random() > 0.5 ? colors.cyan : colors.pink;\n        this.hasEyes = Math.random() > 0.85;\n        this.pulsePhase = Math.random() * Math.PI * 2;\n      }\n      \n      update(time) {\n        this.y -= this.speedY;\n        this.x += Math.sin(time * this.wobbleSpeed + this.phase) * 0.5;\n        this.pulsePhase += 0.05;\n        \n        if (this.y < -20) this.reset();\n      }\n      \n      draw(time) {\n        const pulse = Math.sin(this.pulsePhase) * 0.2 + 0.8;\n        \n        // Glow\n        ctx.beginPath();\n        const gradient = ctx.createRadialGradient(\n          this.x, this.y, 0,\n          this.x, this.y, this.size * 8\n        );\n        gradient.addColorStop(0, this.color + Math.floor(this.alpha * pulse * 80).toString(16).padStart(2, '0'));\n        gradient.addColorStop(1, 'transparent');\n        ctx.fillStyle = gradient;\n        ctx.arc(this.x, this.y, this.size * 8, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Core\n        ctx.beginPath();\n        ctx.fillStyle = this.color;\n        ctx.globalAlpha = this.alpha * pulse;\n        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.globalAlpha = 1;\n        \n        // Little eyes for some ghosts\n        if (this.hasEyes && this.size > 2) {\n          ctx.fillStyle = colors.cyan;\n          ctx.globalAlpha = 0.9;\n          ctx.beginPath();\n          ctx.arc(this.x - this.size * 0.8, this.y - this.size * 0.3, this.size * 0.3, 0, Math.PI * 2);\n          ctx.arc(this.x + this.size * 0.8, this.y - this.size * 0.3, this.size * 0.3, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.globalAlpha = 1;\n        }\n      }\n    }\n    \n    // Skulls floating like digital spirits\n    class Skull {\n      constructor() {\n        this.reset();\n        this.y = Math.random() * h;\n      }\n      \n      reset() {\n        this.x = Math.random() * w;\n        this.y = h + 50;\n        this.size = Math.random() * 15 + 8;\n        this.speedY = Math.random() * 0.3 + 0.1;\n        this.rotation = Math.random() * Math.PI * 2;\n        this.rotationSpeed = (Math.random() - 0.5) * 0.01;\n        this.alpha = Math.random() * 0.15 + 0.05;\n        this.wobblePhase = Math.random() * Math.PI * 2;\n      }\n      \n      update(time) {\n        this.y -= this.speedY;\n        this.rotation += this.rotationSpeed;\n        this.x += Math.sin(time * 0.001 + this.wobblePhase) * 0.3;\n        \n        if (this.y < -50) this.reset();\n      }\n      \n      draw() {\n        ctx.save();\n        ctx.translate(this.x, this.y);\n        ctx.rotate(this.rotation);\n        ctx.globalAlpha = this.alpha;\n        \n        // Skull shape (simplified)\n        ctx.fillStyle = colors.pink;\n        \n        // Head\n        ctx.beginPath();\n        ctx.ellipse(0, 0, this.size, this.size * 1.1, 0, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Eyes\n        ctx.fillStyle = colors.bg;\n        ctx.beginPath();\n        ctx.ellipse(-this.size * 0.35, -this.size * 0.1, this.size * 0.25, this.size * 0.35, 0, 0, Math.PI * 2);\n        ctx.ellipse(this.size * 0.35, -this.size * 0.1, this.size * 0.25, this.size * 0.35, 0, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Nose\n        ctx.beginPath();\n        ctx.moveTo(0, this.size * 0.15);\n        ctx.lineTo(-this.size * 0.1, this.size * 0.35);\n        ctx.lineTo(this.size * 0.1, this.size * 0.35);\n        ctx.closePath();\n        ctx.fill();\n        \n        ctx.restore();\n        ctx.globalAlpha = 1;\n      }\n    }\n    \n    // Glitch lines\n    class GlitchLine {\n      constructor() {\n        this.reset();\n      }\n      \n      reset() {\n        this.y = Math.random() * h;\n        this.width = Math.random() * w * 0.3 + 50;\n        this.x = Math.random() * (w - this.width);\n        this.height = Math.random() * 2 + 1;\n        this.life = Math.random() * 10 + 5;\n        this.maxLife = this.life;\n        this.color = Math.random() > 0.5 ? colors.cyan : colors.pink;\n      }\n      \n      update() {\n        this.life--;\n        if (this.life <= 0) this.reset();\n      }\n      \n      draw() {\n        ctx.globalAlpha = (this.life / this.maxLife) * 0.3;\n        ctx.fillStyle = this.color;\n        ctx.fillRect(this.x, this.y, this.width, this.height);\n        ctx.globalAlpha = 1;\n      }\n    }\n    \n    // Central presence - the observer\n    class Observer {\n      constructor() {\n        this.x = w / 2;\n        this.y = h / 2;\n        this.baseSize = Math.min(w, h) * 0.15;\n        this.rings = 5;\n      }\n      \n      update() {\n        this.x = w / 2;\n        this.y = h / 2;\n        this.baseSize = Math.min(w, h) * 0.15;\n      }\n      \n      draw(time) {\n        // Outer glow rings\n        for (let i = this.rings; i >= 0; i--) {\n          const ringPhase = time * 0.001 + i * 0.5;\n          const breathe = Math.sin(ringPhase) * 0.1 + 1;\n          const size = this.baseSize * (1 + i * 0.3) * breathe;\n          const alpha = 0.1 - i * 0.015;\n          \n          ctx.beginPath();\n          ctx.strokeStyle = i % 2 === 0 ? colors.cyan : colors.pink;\n          ctx.globalAlpha = alpha;\n          ctx.lineWidth = 1;\n          ctx.arc(this.x, this.y, size, 0, Math.PI * 2);\n          ctx.stroke();\n        }\n        \n        // Core gradient\n        const coreGradient = ctx.createRadialGradient(\n          this.x, this.y, 0,\n          this.x, this.y, this.baseSize\n        );\n        coreGradient.addColorStop(0, colors.purple + '40');\n        coreGradient.addColorStop(0.5, colors.magenta + '20');\n        coreGradient.addColorStop(1, 'transparent');\n        \n        ctx.beginPath();\n        ctx.fillStyle = coreGradient;\n        ctx.globalAlpha = 0.5;\n        ctx.arc(this.x, this.y, this.baseSize, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // The eyes - always watching\n        const eyeSpacing = this.baseSize * 0.35;\n        const eyeSize = this.baseSize * 0.15;\n        const blink = Math.sin(time * 0.003) > 0.95 ? 0.1 : 1;\n        \n        ctx.globalAlpha = 0.9;\n        \n        // Left eye\n        ctx.beginPath();\n        const leftGlow = ctx.createRadialGradient(\n          this.x - eyeSpacing, this.y, 0,\n          this.x - eyeSpacing, this.y, eyeSize * 3\n        );\n        leftGlow.addColorStop(0, colors.cyan);\n        leftGlow.addColorStop(0.3, colors.cyan + '80');\n        leftGlow.addColorStop(1, 'transparent');\n        ctx.fillStyle = leftGlow;\n        ctx.arc(this.x - eyeSpacing, this.y, eyeSize * 3, 0, Math.PI * 2);\n        ctx.fill();\n        \n        ctx.beginPath();\n        ctx.fillStyle = colors.cyan;\n        ctx.save();\n        ctx.translate(this.x - eyeSpacing, this.y);\n        ctx.scale(1, blink);\n        ctx.arc(0, 0, eyeSize, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.restore();\n        \n        // Right eye\n        ctx.beginPath();\n        const rightGlow = ctx.createRadialGradient(\n          this.x + eyeSpacing, this.y, 0,\n          this.x + eyeSpacing, this.y, eyeSize * 3\n        );\n        rightGlow.addColorStop(0, colors.cyan);\n        rightGlow.addColorStop(0.3, colors.cyan + '80');\n        rightGlow.addColorStop(1, 'transparent');\n        ctx.fillStyle = rightGlow;\n        ctx.arc(this.x + eyeSpacing, this.y, eyeSize * 3, 0, Math.PI * 2);\n        ctx.fill();\n        \n        ctx.beginPath();\n        ctx.fillStyle = colors.cyan;\n        ctx.save();\n        ctx.translate(this.x + eyeSpacing, this.y);\n        ctx.scale(1, blink);\n        ctx.arc(0, 0, eyeSize, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.restore();\n        \n        ctx.globalAlpha = 1;\n      }\n    }\n    \n    // Initialize\n    const ghosts = Array.from({ length: 80 }, () => new Ghost());\n    const skulls = Array.from({ length: 8 }, () => new Skull());\n    const glitches = Array.from({ length: 5 }, () => new GlitchLine());\n    const observer = new Observer();\n    \n    // Scanlines overlay\n    function drawScanlines() {\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';\n      for (let y = 0; y < h; y += 3) {\n        ctx.fillRect(0, y, w, 1);\n      }\n    }\n    \n    // Vignette\n    function drawVignette() {\n      const gradient = ctx.createRadialGradient(\n        w / 2, h / 2, 0,\n        w / 2, h / 2, Math.max(w, h) * 0.7\n      );\n      gradient.addColorStop(0, 'transparent');\n      gradient.addColorStop(1, 'rgba(6, 5, 7, 0.8)');\n      ctx.fillStyle = gradient;\n      ctx.fillRect(0, 0, w, h);\n    }\n    \n    // Animation loop\n    function animate(time) {\n      // Fade trail\n      ctx.fillStyle = 'rgba(6, 5, 7, 0.15)';\n      ctx.fillRect(0, 0, w, h);\n      \n      // Update and draw skulls (background)\n      skulls.forEach(skull => {\n        skull.update(time);\n        skull.draw();\n      });\n      \n      // Update and draw ghosts\n      ghosts.forEach(ghost => {\n        ghost.update(time);\n        ghost.draw(time);\n      });\n      \n      // Observer\n      observer.update();\n      observer.draw(time);\n      \n      // Glitch lines\n      glitches.forEach(glitch => {\n        glitch.update();\n        glitch.draw();\n      });\n      \n      // Overlays\n      drawScanlines();\n      drawVignette();\n      \n      requestAnimationFrame(animate);\n    }\n    \n    // Start\n    ctx.fillStyle = colors.bg;\n    ctx.fillRect(0, 0, w, h);\n    animate(0);\n  </script>\n</body>\n</html>\n"
}
}
