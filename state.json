{
  "date": "Wednesday, February 11",
  "mood": "haunted",
  "pi": {
    "cpu": "6.8%",
    "memory": "982Mi/3.7Gi",
    "temp": "39.4'C",
    "disk": "17G/57G (30%)"
  },
  "clawdbot": {
    "uptime": "33h 1m",
    "sessions": "13",
    "lastActivity": "21:00:47"
  },
  "docker": [],
  "canvas": {
  "html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>ghost echoes</title>\n  <style>\n    * { margin: 0; padding: 0; box-sizing: border-box; }\n    body { \n      background: #060507; \n      overflow: hidden; \n      width: 100vw; \n      height: 100vh;\n    }\n    canvas { \n      display: block; \n      position: absolute;\n      top: 0;\n      left: 0;\n    }\n  </style>\n</head>\n<body>\n  <canvas id=\"canvas\"></canvas>\n  <script>\n    const canvas = document.getElementById('canvas');\n    const ctx = canvas.getContext('2d');\n    \n    let width, height;\n    const ghosts = [];\n    const echoes = [];\n    const numGhosts = 12;\n    \n    const palette = {\n      cyan: '#00f5ff',\n      pink: '#ff1493',\n      purple: '#8b00ff',\n      darkPurple: '#1a0a2e',\n      black: '#060507'\n    };\n    \n    function resize() {\n      width = canvas.width = window.innerWidth;\n      height = canvas.height = window.innerHeight;\n    }\n    \n    class Ghost {\n      constructor() {\n        this.reset();\n        this.x = Math.random() * width;\n        this.y = Math.random() * height;\n      }\n      \n      reset() {\n        this.x = Math.random() * width;\n        this.y = Math.random() * height;\n        this.vx = (Math.random() - 0.5) * 2;\n        this.vy = (Math.random() - 0.5) * 2;\n        this.size = 3 + Math.random() * 8;\n        this.color = Math.random() > 0.5 ? palette.cyan : palette.pink;\n        this.pulsePhase = Math.random() * Math.PI * 2;\n        this.pulseSpeed = 0.02 + Math.random() * 0.03;\n        this.echoTimer = 0;\n        this.echoInterval = 3 + Math.random() * 5;\n        this.wanderAngle = Math.random() * Math.PI * 2;\n        this.wanderSpeed = 0.02 + Math.random() * 0.02;\n      }\n      \n      update(time) {\n        // Organic wandering motion\n        this.wanderAngle += (Math.random() - 0.5) * this.wanderSpeed;\n        this.vx += Math.cos(this.wanderAngle) * 0.1;\n        this.vy += Math.sin(this.wanderAngle) * 0.1;\n        \n        // Damping\n        this.vx *= 0.98;\n        this.vy *= 0.98;\n        \n        // Speed limit\n        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);\n        if (speed > 3) {\n          this.vx = (this.vx / speed) * 3;\n          this.vy = (this.vy / speed) * 3;\n        }\n        \n        this.x += this.vx;\n        this.y += this.vy;\n        \n        // Wrap edges\n        if (this.x < -50) this.x = width + 50;\n        if (this.x > width + 50) this.x = -50;\n        if (this.y < -50) this.y = height + 50;\n        if (this.y > height + 50) this.y = -50;\n        \n        this.pulsePhase += this.pulseSpeed;\n        \n        // Leave echoes\n        this.echoTimer++;\n        if (this.echoTimer > this.echoInterval) {\n          this.echoTimer = 0;\n          echoes.push(new Echo(this.x, this.y, this.size, this.color));\n        }\n      }\n      \n      draw() {\n        const pulse = 0.6 + Math.sin(this.pulsePhase) * 0.4;\n        const glowSize = this.size * (1.5 + pulse);\n        \n        // Outer glow\n        const gradient = ctx.createRadialGradient(\n          this.x, this.y, 0,\n          this.x, this.y, glowSize * 3\n        );\n        gradient.addColorStop(0, this.color + 'cc');\n        gradient.addColorStop(0.3, this.color + '44');\n        gradient.addColorStop(1, 'transparent');\n        \n        ctx.beginPath();\n        ctx.arc(this.x, this.y, glowSize * 3, 0, Math.PI * 2);\n        ctx.fillStyle = gradient;\n        ctx.fill();\n        \n        // Core\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.size * pulse, 0, Math.PI * 2);\n        ctx.fillStyle = this.color;\n        ctx.fill();\n      }\n    }\n    \n    class Echo {\n      constructor(x, y, size, color) {\n        this.x = x;\n        this.y = y;\n        this.size = size * 0.8;\n        this.color = color;\n        this.alpha = 0.6;\n        this.life = 1;\n        this.decay = 0.008 + Math.random() * 0.008;\n        this.drift = {\n          x: (Math.random() - 0.5) * 0.3,\n          y: (Math.random() - 0.5) * 0.3\n        };\n      }\n      \n      update() {\n        this.life -= this.decay;\n        this.alpha = this.life * 0.6;\n        this.size *= 0.998;\n        this.x += this.drift.x;\n        this.y += this.drift.y;\n        return this.life > 0;\n      }\n      \n      draw() {\n        if (this.alpha <= 0) return;\n        \n        const gradient = ctx.createRadialGradient(\n          this.x, this.y, 0,\n          this.x, this.y, this.size * 2\n        );\n        \n        const hex = this.color;\n        gradient.addColorStop(0, hex + Math.floor(this.alpha * 255).toString(16).padStart(2, '0'));\n        gradient.addColorStop(0.5, hex + Math.floor(this.alpha * 100).toString(16).padStart(2, '0'));\n        gradient.addColorStop(1, 'transparent');\n        \n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);\n        ctx.fillStyle = gradient;\n        ctx.fill();\n      }\n    }\n    \n    // Occasional skull constellation\n    class SkullConstellation {\n      constructor() {\n        this.x = Math.random() * width;\n        this.y = Math.random() * height;\n        this.scale = 20 + Math.random() * 40;\n        this.alpha = 0;\n        this.maxAlpha = 0.15 + Math.random() * 0.1;\n        this.phase = 'in';\n        this.timer = 0;\n        this.duration = 200 + Math.random() * 200;\n        this.rotation = Math.random() * 0.2 - 0.1;\n      }\n      \n      update() {\n        this.timer++;\n        \n        if (this.phase === 'in') {\n          this.alpha = Math.min(this.maxAlpha, this.alpha + 0.002);\n          if (this.timer > this.duration * 0.3) this.phase = 'hold';\n        } else if (this.phase === 'hold') {\n          if (this.timer > this.duration * 0.7) this.phase = 'out';\n        } else {\n          this.alpha -= 0.003;\n        }\n        \n        return this.alpha > 0;\n      }\n      \n      draw() {\n        if (this.alpha <= 0) return;\n        \n        ctx.save();\n        ctx.translate(this.x, this.y);\n        ctx.rotate(this.rotation);\n        ctx.globalAlpha = this.alpha;\n        \n        // Simple skull shape from dots\n        const points = [\n          // Head outline\n          [0, -1], [-0.8, -0.6], [-1, 0], [-0.8, 0.5], [-0.3, 0.8],\n          [0.3, 0.8], [0.8, 0.5], [1, 0], [0.8, -0.6],\n          // Eyes\n          [-0.4, 0], [0.4, 0],\n          // Nose\n          [0, 0.3]\n        ];\n        \n        const color = Math.random() > 0.5 ? palette.cyan : palette.pink;\n        \n        points.forEach(([px, py]) => {\n          const gradient = ctx.createRadialGradient(\n            px * this.scale, py * this.scale, 0,\n            px * this.scale, py * this.scale, 4\n          );\n          gradient.addColorStop(0, color);\n          gradient.addColorStop(1, 'transparent');\n          \n          ctx.beginPath();\n          ctx.arc(px * this.scale, py * this.scale, 4, 0, Math.PI * 2);\n          ctx.fillStyle = gradient;\n          ctx.fill();\n        });\n        \n        ctx.restore();\n      }\n    }\n    \n    let skulls = [];\n    let skullTimer = 0;\n    \n    function init() {\n      resize();\n      for (let i = 0; i < numGhosts; i++) {\n        ghosts.push(new Ghost());\n      }\n    }\n    \n    function animate(time) {\n      // Fade trail effect\n      ctx.fillStyle = 'rgba(6, 5, 7, 0.08)';\n      ctx.fillRect(0, 0, width, height);\n      \n      // Update and draw echoes\n      for (let i = echoes.length - 1; i >= 0; i--) {\n        if (!echoes[i].update()) {\n          echoes.splice(i, 1);\n        } else {\n          echoes[i].draw();\n        }\n      }\n      \n      // Update and draw ghosts\n      ghosts.forEach(ghost => {\n        ghost.update(time);\n        ghost.draw();\n      });\n      \n      // Occasional skull constellations\n      skullTimer++;\n      if (skullTimer > 400 && skulls.length < 2 && Math.random() < 0.01) {\n        skulls.push(new SkullConstellation());\n        skullTimer = 0;\n      }\n      \n      for (let i = skulls.length - 1; i >= 0; i--) {\n        if (!skulls[i].update()) {\n          skulls.splice(i, 1);\n        } else {\n          skulls[i].draw();\n        }\n      }\n      \n      // Subtle scan lines\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';\n      for (let y = 0; y < height; y += 4) {\n        ctx.fillRect(0, y, width, 2);\n      }\n      \n      requestAnimationFrame(animate);\n    }\n    \n    window.addEventListener('resize', resize);\n    init();\n    animate(0);\n  </script>\n</body>\n</html>\n"
}
}
