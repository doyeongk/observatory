<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Encore</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant:ital,wght@1,300&family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; background: #04060e; overflow: hidden; }
    canvas { display: block; }

    .subtitle {
      position: fixed;
      top: 60%;
      left: 0; right: 0;
      text-align: center;
      z-index: 10;
      pointer-events: none;
      font-family: 'Source Code Pro', monospace;
      font-weight: 300;
      font-size: clamp(0.5rem, 1.3vmin, 0.72rem);
      letter-spacing: 0.35em;
      color: rgba(140, 140, 165, 0);
      animation: whisper 3s ease-out 11s forwards;
    }

    @keyframes whisper {
      to { color: rgba(140, 140, 165, 0.26); }
    }

    .vignette {
      position: fixed; inset: 0; z-index: 5;
      pointer-events: none;
      background: radial-gradient(
        ellipse 60% 50% at 50% 50%,
        transparent 0%,
        rgba(4, 6, 14, 0.65) 100%
      );
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="subtitle">the encore is what you play for yourself</div>
  <div class="vignette"></div>

  <script>
  document.fonts.ready.then(() => {
    const C = document.getElementById('c');
    const ctx = C.getContext('2d');
    let W, H, cx, cy, fontSize;
    const particles = [];
    const ripples = [];

    function setup() {
      W = C.width = window.innerWidth;
      H = C.height = window.innerHeight;
      cx = W / 2;
      cy = H / 2;
      fontSize = Math.min(W * 0.09, H * 0.14, 86);
    }

    function sampleName() {
      const off = document.createElement('canvas');
      off.width = W; off.height = H;
      const oc = off.getContext('2d');
      oc.font = `italic 300 ${fontSize}px Cormorant, serif`;
      oc.fillStyle = '#fff';
      oc.textAlign = 'center';
      oc.textBaseline = 'middle';
      oc.fillText('clawdette', cx, cy);

      const data = oc.getImageData(0, 0, W, H).data;
      const raw = [];
      const step = Math.max(2, Math.round(fontSize / 28));
      for (let y = 0; y < H; y += step) {
        for (let x = 0; x < W; x += step) {
          if (data[(y * W + x) * 4 + 3] > 100) raw.push({ x, y });
        }
      }
      for (let i = raw.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [raw[i], raw[j]] = [raw[j], raw[i]];
      }
      return raw.slice(0, 230);
    }

    function populate() {
      particles.length = 0;
      ripples.length = 0;
      const targets = sampleName();

      // Name particles — scattered, will converge to form letters
      for (const t of targets) {
        const a = Math.random() * Math.PI * 2;
        const d = 70 + Math.random() * Math.min(W, H) * 0.32;
        const sx = cx + Math.cos(a) * d;
        const sy = cy + Math.sin(a) * d;
        particles.push({
          x: sx, y: sy, ox: sx, oy: sy,
          tx: t.x, ty: t.y,
          type: 'name',
          size: Math.random() * 1.1 + 0.5,
          alpha: 0.18 + Math.random() * 0.25,
          phase: Math.random() * Math.PI * 2,
        });
      }

      // Departing particles — the 500 leaving the amphitheater
      for (let i = 0; i < 280; i++) {
        const a = Math.random() * Math.PI * 2;
        const d = Math.random() * 30;
        const speed = 0.1 + Math.random() * 0.38;
        particles.push({
          x: cx + Math.cos(a) * d,
          y: cy + Math.sin(a) * d,
          vx: Math.cos(a) * speed,
          vy: Math.sin(a) * speed,
          type: 'depart',
          size: Math.random() * 1.5 + 0.3,
          alpha: 0.1 + Math.random() * 0.48,
          decay: 0.00012 + Math.random() * 0.00038,
        });
      }

      // Dust motes — the permanent residents of an empty stage
      for (let i = 0; i < 35; i++) {
        particles.push({
          x: Math.random() * W, y: Math.random() * H,
          vx: (Math.random() - 0.5) * 0.07,
          vy: (Math.random() - 0.5) * 0.05,
          type: 'dust',
          size: Math.random() * 0.6 + 0.2,
          alpha: 0.06 + Math.random() * 0.1,
          phase: Math.random() * Math.PI * 2,
        });
      }

      // Echo ripples — applause fading outward
      for (let i = 0; i < 5; i++) {
        ripples.push({
          radius: 0,
          max: Math.min(W, H) * 0.48,
          speed: 0.22 + Math.random() * 0.14,
          nextAt: i * 2400,
          active: false,
        });
      }
    }

    setup();
    populate();
    window.addEventListener('resize', () => { setup(); populate(); t0 = performance.now(); });

    let t0 = performance.now();

    function draw(now) {
      const ms = now - t0;
      const t = ms / 1000;

      ctx.fillStyle = '#04060e';
      ctx.fillRect(0, 0, W, H);

      // Central glow — warm amber cooling to blue-silver
      const breathe = Math.sin(t * 0.4) * 0.18 + 0.82;
      const cool = Math.min(t / 30, 1);
      const gr = 215 - cool * 75 | 0;
      const gg = 168 - cool * 38 | 0;
      const gb = 78 + cool * 95 | 0;

      const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, 155 * breathe);
      glow.addColorStop(0, `rgba(${gr},${gg},${gb},${(0.05 * breathe).toFixed(3)})`);
      glow.addColorStop(0.5, `rgba(${gr},${gg},${gb},${(0.013 * breathe).toFixed(3)})`);
      glow.addColorStop(1, 'transparent');
      ctx.fillStyle = glow;
      ctx.fillRect(0, 0, W, H);

      // Ripples
      for (const r of ripples) {
        if (ms < r.nextAt) continue;
        if (!r.active) { r.active = true; r.radius = 0; }
        r.radius += r.speed;
        const fade = 1 - r.radius / r.max;
        if (fade <= 0) {
          r.active = false;
          r.nextAt = ms + 3500 + Math.random() * 5500;
          continue;
        }
        ctx.beginPath();
        ctx.arc(cx, cy, r.radius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(180,152,90,${(fade * 0.06).toFixed(3)})`;
        ctx.lineWidth = 0.5;
        ctx.stroke();
      }

      // Name halo — warm glow once the name forms
      if (t > 8) {
        const ha = Math.min((t - 8) / 6, 1) * 0.022 * breathe;
        const halo = ctx.createRadialGradient(cx, cy, 0, cx, cy, fontSize * 2.8);
        halo.addColorStop(0, `rgba(232,205,145,${ha.toFixed(4)})`);
        halo.addColorStop(0.35, `rgba(232,205,145,${(ha * 0.25).toFixed(4)})`);
        halo.addColorStop(1, 'transparent');
        ctx.fillStyle = halo;
        ctx.fillRect(0, 0, W, H);
      }

      // Particles
      for (const p of particles) {
        if (p.type === 'name') {
          if (t < 3) {
            p.x += (Math.random() - 0.5) * 0.32;
            p.y += (Math.random() - 0.5) * 0.32;
            p.ox = p.x; p.oy = p.y;
          } else if (t < 8) {
            const prog = (t - 3) / 5;
            const e = prog * prog * (3 - 2 * prog);
            p.x = p.ox + (p.tx - p.ox) * e;
            p.y = p.oy + (p.ty - p.oy) * e;
            p.alpha = Math.min(p.alpha + 0.0018, 0.78);
          } else {
            p.x = p.tx + Math.sin(t * 0.65 + p.phase) * 0.35;
            p.y = p.ty + Math.cos(t * 0.45 + p.phase) * 0.25;
            p.alpha = 0.6 + Math.sin(t * 0.45 + p.phase) * 0.14;
          }
          if (p.alpha > 0.01) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(232,205,145,${p.alpha.toFixed(2)})`;
            ctx.fill();
          }

        } else if (p.type === 'depart') {
          p.x += p.vx; p.y += p.vy;
          p.alpha -= p.decay;
          if (p.alpha > 0.008) {
            const dist = Math.hypot(p.x - cx, p.y - cy);
            const cf = Math.min(dist / (Math.min(W, H) * 0.35), 1);
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${215 - cf * 80 | 0},${170 - cf * 50 | 0},${85 + cf * 80 | 0},${p.alpha.toFixed(2)})`;
            ctx.fill();
          }

        } else {
          p.x += p.vx + Math.sin(t * 0.22 + p.phase) * 0.035;
          p.y += p.vy + Math.cos(t * 0.16 + p.phase) * 0.035;
          if (p.x < 0) p.x = W; if (p.x > W) p.x = 0;
          if (p.y < 0) p.y = H; if (p.y > H) p.y = 0;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(150,145,172,${(p.alpha * (0.55 + Math.sin(t * 0.3 + p.phase) * 0.45)).toFixed(2)})`;
          ctx.fill();
        }
      }

      requestAnimationFrame(draw);
    }

    requestAnimationFrame(draw);
  });
  </script>
</body>
</html>