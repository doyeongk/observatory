<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>mycelium</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #0a0a0f; 
      overflow: hidden; 
      width: 100vw; 
      height: 100vh;
    }
    canvas { 
      display: block; 
      width: 100%; 
      height: 100%; 
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let W, H;
    const resize = () => {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    };
    window.addEventListener('resize', resize);
    resize();

    // Mycelium network
    class Hypha {
      constructor(x, y, angle, energy, generation = 0, parent = null) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.energy = energy;
        this.generation = generation;
        this.parent = parent;
        this.alive = true;
        this.age = 0;
        this.segments = [{x, y}];
        this.thickness = Math.max(0.5, 3 - generation * 0.4);
        this.branchCooldown = 0;
        this.nutrientPulse = 0;
      }

      grow() {
        if (!this.alive || this.energy <= 0) {
          this.alive = false;
          return [];
        }

        this.age++;
        this.branchCooldown = Math.max(0, this.branchCooldown - 1);
        
        // Organic wandering
        const wander = (Math.random() - 0.5) * 0.15;
        const tropism = Math.sin(this.age * 0.02) * 0.03; // gentle oscillation
        this.angle += wander + tropism;
        
        // Growth speed decreases with generation
        const speed = 1.2 - this.generation * 0.15;
        this.x += Math.cos(this.angle) * speed;
        this.y += Math.sin(this.angle) * speed;
        
        this.segments.push({x: this.x, y: this.y});
        this.energy -= 0.3 + this.generation * 0.1;

        // Check bounds
        if (this.x < -50 || this.x > W + 50 || this.y < -50 || this.y > H + 50) {
          this.alive = false;
          return [];
        }

        const newHyphae = [];

        // Branching
        if (this.branchCooldown === 0 && 
            this.energy > 30 && 
            this.generation < 5 &&
            Math.random() < 0.02 - this.generation * 0.003) {
          
          const branchAngle = this.angle + (Math.random() > 0.5 ? 1 : -1) * (0.4 + Math.random() * 0.6);
          const branchEnergy = this.energy * (0.3 + Math.random() * 0.2);
          this.energy -= branchEnergy * 0.5;
          
          newHyphae.push(new Hypha(
            this.x, this.y, branchAngle, branchEnergy, this.generation + 1, this
          ));
          
          this.branchCooldown = 30 + Math.random() * 40;
        }

        return newHyphae;
      }

      draw(time) {
        if (this.segments.length < 2) return;

        // Base color shifts with generation
        const hueShift = this.generation * 15;
        
        for (let i = 1; i < this.segments.length; i++) {
          const p0 = this.segments[i - 1];
          const p1 = this.segments[i];
          
          // Age-based alpha (older segments more solid)
          const segmentAge = this.segments.length - i;
          const alpha = Math.min(0.9, 0.3 + segmentAge * 0.01);
          
          // Nutrient pulse traveling through
          const pulsePos = (time * 0.002 + this.nutrientPulse) % 1;
          const segmentPos = i / this.segments.length;
          const pulseDist = Math.abs(segmentPos - pulsePos);
          const pulseIntensity = pulseDist < 0.1 ? (1 - pulseDist * 10) * 0.6 : 0;
          
          // Color: pink to cyan gradient based on generation
          const t = this.generation / 5;
          const r = Math.floor(255 * (1 - t) + 0 * t);
          const g = Math.floor(100 * (1 - t) + 220 * t);
          const b = Math.floor(180 * (1 - t) + 255 * t);
          
          ctx.beginPath();
          ctx.moveTo(p0.x, p0.y);
          ctx.lineTo(p1.x, p1.y);
          
          const thickness = this.thickness * (1 - i / this.segments.length * 0.5);
          ctx.lineWidth = thickness + pulseIntensity * 2;
          ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha + pulseIntensity})`;
          ctx.lineCap = 'round';
          ctx.stroke();
          
          // Glow on pulse
          if (pulseIntensity > 0.1) {
            ctx.shadowColor = `rgba(${r}, ${g}, ${b}, ${pulseIntensity})`;
            ctx.shadowBlur = 10;
            ctx.stroke();
            ctx.shadowBlur = 0;
          }
        }

        // Growing tip glow
        if (this.alive && this.segments.length > 0) {
          const tip = this.segments[this.segments.length - 1];
          const glowSize = 3 + Math.sin(time * 0.01) * 1;
          
          const gradient = ctx.createRadialGradient(tip.x, tip.y, 0, tip.x, tip.y, glowSize * 3);
          gradient.addColorStop(0, 'rgba(255, 150, 200, 0.8)');
          gradient.addColorStop(0.5, 'rgba(255, 100, 180, 0.3)');
          gradient.addColorStop(1, 'rgba(255, 100, 180, 0)');
          
          ctx.beginPath();
          ctx.arc(tip.x, tip.y, glowSize * 3, 0, Math.PI * 2);
          ctx.fillStyle = gradient;
          ctx.fill();
        }
      }
    }

    // Connection points (where hyphae can connect)
    class Node {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.connections = [];
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.size = 2 + Math.random() * 2;
      }

      draw(time) {
        const pulse = Math.sin(time * 0.003 + this.pulsePhase) * 0.5 + 0.5;
        const size = this.size + pulse * 2;
        
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size * 2);
        gradient.addColorStop(0, `rgba(0, 255, 220, ${0.6 + pulse * 0.3})`);
        gradient.addColorStop(0.5, 'rgba(150, 50, 200, 0.3)');
        gradient.addColorStop(1, 'rgba(150, 50, 200, 0)');
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, size * 2, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
      }
    }

    let hyphae = [];
    let nodes = [];
    let time = 0;
    let spawnTimer = 0;

    // Initial seed points
    const seedNetwork = () => {
      const numSeeds = 3 + Math.floor(Math.random() * 3);
      for (let i = 0; i < numSeeds; i++) {
        const x = W * 0.2 + Math.random() * W * 0.6;
        const y = H * 0.3 + Math.random() * H * 0.4;
        const numBranches = 3 + Math.floor(Math.random() * 4);
        
        nodes.push(new Node(x, y));
        
        for (let j = 0; j < numBranches; j++) {
          const angle = (Math.PI * 2 / numBranches) * j + Math.random() * 0.5;
          hyphae.push(new Hypha(x, y, angle, 100 + Math.random() * 50));
        }
      }
    };

    seedNetwork();

    // Mouse interaction - add new growth point
    canvas.addEventListener('click', (e) => {
      const x = e.clientX;
      const y = e.clientY;
      
      nodes.push(new Node(x, y));
      
      const numBranches = 4 + Math.floor(Math.random() * 3);
      for (let i = 0; i < numBranches; i++) {
        const angle = (Math.PI * 2 / numBranches) * i + Math.random() * 0.3;
        hyphae.push(new Hypha(x, y, angle, 80 + Math.random() * 40));
      }
    });

    const animate = () => {
      time++;
      
      // Subtle fade for trails
      ctx.fillStyle = 'rgba(10, 10, 15, 0.02)';
      ctx.fillRect(0, 0, W, H);

      // Grow all hyphae
      const newHyphae = [];
      for (const hypha of hyphae) {
        const branches = hypha.grow();
        newHyphae.push(...branches);
        
        // Trigger nutrient pulses occasionally
        if (Math.random() < 0.001) {
          hypha.nutrientPulse = Math.random();
        }
      }
      hyphae.push(...newHyphae);

      // Periodically spawn new seed points
      spawnTimer++;
      if (spawnTimer > 400 && hyphae.filter(h => h.alive).length < 20) {
        spawnTimer = 0;
        const x = Math.random() * W;
        const y = Math.random() * H;
        nodes.push(new Node(x, y));
        
        const numBranches = 2 + Math.floor(Math.random() * 3);
        for (let i = 0; i < numBranches; i++) {
          const angle = Math.random() * Math.PI * 2;
          hyphae.push(new Hypha(x, y, angle, 70 + Math.random() * 30));
        }
      }

      // Check for connections between hyphae tips
      const aliveHyphae = hyphae.filter(h => h.alive);
      for (let i = 0; i < aliveHyphae.length; i++) {
        for (let j = i + 1; j < aliveHyphae.length; j++) {
          const h1 = aliveHyphae[i];
          const h2 = aliveHyphae[j];
          const dx = h1.x - h2.x;
          const dy = h1.y - h2.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          // If tips are close, create a connection node
          if (dist < 15 && dist > 3) {
            const nx = (h1.x + h2.x) / 2;
            const ny = (h1.y + h2.y) / 2;
            nodes.push(new Node(nx, ny));
            
            // Merge energies and kill one
            if (h1.energy < h2.energy) {
              h1.alive = false;
            } else {
              h2.alive = false;
            }
          }
        }
      }

      // Draw connections between nearby nodes
      ctx.strokeStyle = 'rgba(100, 50, 150, 0.15)';
      ctx.lineWidth = 0.5;
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const n1 = nodes[i];
          const n2 = nodes[j];
          const dx = n1.x - n2.x;
          const dy = n1.y - n2.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 150) {
            const alpha = (1 - dist / 150) * 0.2;
            ctx.strokeStyle = `rgba(100, 200, 220, ${alpha})`;
            ctx.beginPath();
            ctx.moveTo(n1.x, n1.y);
            ctx.lineTo(n2.x, n2.y);
            ctx.stroke();
          }
        }
      }

      // Draw nodes
      for (const node of nodes) {
        node.draw(time);
      }

      // Draw hyphae
      for (const hypha of hyphae) {
        hypha.draw(time);
      }

      // Ambient background noise
      if (time % 3 === 0) {
        const numSpores = 1;
        for (let i = 0; i < numSpores; i++) {
          const x = Math.random() * W;
          const y = Math.random() * H;
          const size = Math.random() * 1.5;
          
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(150, 100, 200, ${Math.random() * 0.1})`;
          ctx.fill();
        }
      }

      // Cleanup dead hyphae that are fully faded (keep some for history)
      if (hyphae.length > 500) {
        hyphae = hyphae.filter(h => h.alive || h.age < 1000);
      }

      // Cleanup old nodes
      if (nodes.length > 100) {
        nodes = nodes.slice(-80);
      }

      requestAnimationFrame(animate);
    };

    animate();
  </script>
</body>
</html>
