<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ghost echoes</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #060507; 
      overflow: hidden; 
      width: 100vw; 
      height: 100vh;
    }
    canvas { 
      display: block; 
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    const ghosts = [];
    const echoes = [];
    const numGhosts = 12;
    
    const palette = {
      cyan: '#00f5ff',
      pink: '#ff1493',
      purple: '#8b00ff',
      darkPurple: '#1a0a2e',
      black: '#060507'
    };
    
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    
    class Ghost {
      constructor() {
        this.reset();
        this.x = Math.random() * width;
        this.y = Math.random() * height;
      }
      
      reset() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2;
        this.size = 3 + Math.random() * 8;
        this.color = Math.random() > 0.5 ? palette.cyan : palette.pink;
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.pulseSpeed = 0.02 + Math.random() * 0.03;
        this.echoTimer = 0;
        this.echoInterval = 3 + Math.random() * 5;
        this.wanderAngle = Math.random() * Math.PI * 2;
        this.wanderSpeed = 0.02 + Math.random() * 0.02;
      }
      
      update(time) {
        // Organic wandering motion
        this.wanderAngle += (Math.random() - 0.5) * this.wanderSpeed;
        this.vx += Math.cos(this.wanderAngle) * 0.1;
        this.vy += Math.sin(this.wanderAngle) * 0.1;
        
        // Damping
        this.vx *= 0.98;
        this.vy *= 0.98;
        
        // Speed limit
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        if (speed > 3) {
          this.vx = (this.vx / speed) * 3;
          this.vy = (this.vy / speed) * 3;
        }
        
        this.x += this.vx;
        this.y += this.vy;
        
        // Wrap edges
        if (this.x < -50) this.x = width + 50;
        if (this.x > width + 50) this.x = -50;
        if (this.y < -50) this.y = height + 50;
        if (this.y > height + 50) this.y = -50;
        
        this.pulsePhase += this.pulseSpeed;
        
        // Leave echoes
        this.echoTimer++;
        if (this.echoTimer > this.echoInterval) {
          this.echoTimer = 0;
          echoes.push(new Echo(this.x, this.y, this.size, this.color));
        }
      }
      
      draw() {
        const pulse = 0.6 + Math.sin(this.pulsePhase) * 0.4;
        const glowSize = this.size * (1.5 + pulse);
        
        // Outer glow
        const gradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, glowSize * 3
        );
        gradient.addColorStop(0, this.color + 'cc');
        gradient.addColorStop(0.3, this.color + '44');
        gradient.addColorStop(1, 'transparent');
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, glowSize * 3, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Core
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * pulse, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
      }
    }
    
    class Echo {
      constructor(x, y, size, color) {
        this.x = x;
        this.y = y;
        this.size = size * 0.8;
        this.color = color;
        this.alpha = 0.6;
        this.life = 1;
        this.decay = 0.008 + Math.random() * 0.008;
        this.drift = {
          x: (Math.random() - 0.5) * 0.3,
          y: (Math.random() - 0.5) * 0.3
        };
      }
      
      update() {
        this.life -= this.decay;
        this.alpha = this.life * 0.6;
        this.size *= 0.998;
        this.x += this.drift.x;
        this.y += this.drift.y;
        return this.life > 0;
      }
      
      draw() {
        if (this.alpha <= 0) return;
        
        const gradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, this.size * 2
        );
        
        const hex = this.color;
        gradient.addColorStop(0, hex + Math.floor(this.alpha * 255).toString(16).padStart(2, '0'));
        gradient.addColorStop(0.5, hex + Math.floor(this.alpha * 100).toString(16).padStart(2, '0'));
        gradient.addColorStop(1, 'transparent');
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
      }
    }
    
    // Occasional skull constellation
    class SkullConstellation {
      constructor() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.scale = 20 + Math.random() * 40;
        this.alpha = 0;
        this.maxAlpha = 0.15 + Math.random() * 0.1;
        this.phase = 'in';
        this.timer = 0;
        this.duration = 200 + Math.random() * 200;
        this.rotation = Math.random() * 0.2 - 0.1;
      }
      
      update() {
        this.timer++;
        
        if (this.phase === 'in') {
          this.alpha = Math.min(this.maxAlpha, this.alpha + 0.002);
          if (this.timer > this.duration * 0.3) this.phase = 'hold';
        } else if (this.phase === 'hold') {
          if (this.timer > this.duration * 0.7) this.phase = 'out';
        } else {
          this.alpha -= 0.003;
        }
        
        return this.alpha > 0;
      }
      
      draw() {
        if (this.alpha <= 0) return;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.globalAlpha = this.alpha;
        
        // Simple skull shape from dots
        const points = [
          // Head outline
          [0, -1], [-0.8, -0.6], [-1, 0], [-0.8, 0.5], [-0.3, 0.8],
          [0.3, 0.8], [0.8, 0.5], [1, 0], [0.8, -0.6],
          // Eyes
          [-0.4, 0], [0.4, 0],
          // Nose
          [0, 0.3]
        ];
        
        const color = Math.random() > 0.5 ? palette.cyan : palette.pink;
        
        points.forEach(([px, py]) => {
          const gradient = ctx.createRadialGradient(
            px * this.scale, py * this.scale, 0,
            px * this.scale, py * this.scale, 4
          );
          gradient.addColorStop(0, color);
          gradient.addColorStop(1, 'transparent');
          
          ctx.beginPath();
          ctx.arc(px * this.scale, py * this.scale, 4, 0, Math.PI * 2);
          ctx.fillStyle = gradient;
          ctx.fill();
        });
        
        ctx.restore();
      }
    }
    
    let skulls = [];
    let skullTimer = 0;
    
    function init() {
      resize();
      for (let i = 0; i < numGhosts; i++) {
        ghosts.push(new Ghost());
      }
    }
    
    function animate(time) {
      // Fade trail effect
      ctx.fillStyle = 'rgba(6, 5, 7, 0.08)';
      ctx.fillRect(0, 0, width, height);
      
      // Update and draw echoes
      for (let i = echoes.length - 1; i >= 0; i--) {
        if (!echoes[i].update()) {
          echoes.splice(i, 1);
        } else {
          echoes[i].draw();
        }
      }
      
      // Update and draw ghosts
      ghosts.forEach(ghost => {
        ghost.update(time);
        ghost.draw();
      });
      
      // Occasional skull constellations
      skullTimer++;
      if (skullTimer > 400 && skulls.length < 2 && Math.random() < 0.01) {
        skulls.push(new SkullConstellation());
        skullTimer = 0;
      }
      
      for (let i = skulls.length - 1; i >= 0; i--) {
        if (!skulls[i].update()) {
          skulls.splice(i, 1);
        } else {
          skulls[i].draw();
        }
      }
      
      // Subtle scan lines
      ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
      for (let y = 0; y < height; y += 4) {
        ctx.fillRect(0, y, width, 2);
      }
      
      requestAnimationFrame(animate);
    }
    
    window.addEventListener('resize', resize);
    init();
    animate(0);
  </script>
</body>
</html>
