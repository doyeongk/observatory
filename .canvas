<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Overture</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bodoni+Moda:ital,opsz,wght@1,6..96,400&family=JetBrains+Mono:wght@200&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%; height: 100%;
      background: #07050f;
      overflow: hidden;
      cursor: default;
    }

    canvas#scene { position: fixed; inset: 0; z-index: 1; }

    /* Stage light — warm downward wash from above */
    .stage-light {
      position: fixed;
      top: -10%;
      left: 50%;
      transform: translateX(-50%);
      width: 50vmin;
      height: 75vmin;
      z-index: 2;
      pointer-events: none;
      background: radial-gradient(
        ellipse 50% 65% at 50% 15%,
        rgba(210, 165, 80, 0.04) 0%,
        rgba(196, 148, 58, 0.018) 35%,
        rgba(160, 110, 50, 0.005) 65%,
        transparent 100%
      );
      animation: light-pulse 10s ease-in-out infinite;
    }

    @keyframes light-pulse {
      0%, 100% { opacity: 0.55; transform: translateX(-50%) scaleX(1); }
      50% { opacity: 1; transform: translateX(-50%) scaleX(1.05); }
    }

    /* Dawn ambient — warm wash from right */
    .dawn-ambient {
      position: fixed;
      inset: 0;
      z-index: 2;
      pointer-events: none;
      background: radial-gradient(
        ellipse 45% 55% at 88% 50%,
        rgba(180, 130, 50, 0.022) 0%,
        rgba(150, 100, 40, 0.008) 45%,
        transparent 80%
      );
    }

    /* Stage edge — the horizon between speaker and audience */
    .stage-edge {
      position: fixed;
      top: 38%;
      left: 0; right: 0;
      height: 1px;
      z-index: 3;
      pointer-events: none;
      background: linear-gradient(
        90deg,
        transparent 12%,
        rgba(196, 148, 58, 0.035) 32%,
        rgba(210, 170, 90, 0.07) 50%,
        rgba(196, 148, 58, 0.035) 68%,
        transparent 88%
      );
      animation: edge-glow 8s ease-in-out infinite;
    }

    @keyframes edge-glow {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 1; }
    }

    /* Text — asymmetric editorial, top-left */
    .text-layer {
      position: fixed;
      top: 7%;
      left: 5%;
      z-index: 10;
      pointer-events: none;
    }

    .text-layer::before {
      content: '';
      position: absolute;
      inset: -2em -3em;
      background: radial-gradient(ellipse at 10% 20%, rgba(7, 5, 15, 0.6) 0%, transparent 70%);
      z-index: -1;
    }

    .title {
      font-family: 'Bodoni Moda', serif;
      font-style: italic;
      font-weight: 400;
      font-size: clamp(2.2rem, 6.5vmin, 5rem);
      letter-spacing: 0.03em;
      color: rgba(220, 182, 110, 0);
      line-height: 1;
      animation: title-reveal 22s ease-in-out infinite;
    }

    .subtitle {
      margin-top: 1.1em;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 200;
      font-size: clamp(0.3rem, 0.62vmin, 0.48rem);
      letter-spacing: 0.45em;
      text-transform: lowercase;
      color: rgba(150, 140, 165, 0);
      animation: sub-reveal 22s ease-in-out infinite 2.5s;
    }

    @keyframes title-reveal {
      0%, 100% { color: rgba(220, 182, 110, 0); }
      15%, 85% { color: rgba(220, 182, 110, 0.32); }
    }

    @keyframes sub-reveal {
      0%, 100% { color: rgba(150, 140, 165, 0); }
      15%, 85% { color: rgba(150, 140, 165, 0.42); }
    }

    /* Film grain */
    .grain {
      position: fixed; inset: 0;
      pointer-events: none;
      z-index: 90;
      mix-blend-mode: overlay;
      opacity: 0.12;
    }
    .grain svg { width: 100%; height: 100%; display: block; }
  </style>
</head>
<body>

  <canvas id="scene"></canvas>

  <div class="stage-light"></div>
  <div class="dawn-ambient"></div>
  <div class="stage-edge"></div>

  <div class="text-layer">
    <div class="title">Overture</div>
    <div class="subtitle">they're already listening</div>
  </div>

  <div class="grain">
    <svg xmlns="http://www.w3.org/2000/svg">
      <filter id="g">
        <feTurbulence type="fractalNoise" baseFrequency="0.65" numOctaves="4" stitchTiles="stitch"/>
        <feColorMatrix type="saturate" values="0"/>
      </filter>
      <rect width="100%" height="100%" filter="url(#g)" opacity="0.04"/>
    </svg>
  </div>

  <script>
    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');
    let W, H;

    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
      recalcTargets();
    }

    // === 500 SOULS — the audience converging ===
    const N = 500;
    const souls = [];

    for (let i = 0; i < N; i++) {
      const rowFrac = Math.pow(Math.random(), 0.55);
      const arcSpread = 0.26 + rowFrac * 0.24;

      souls.push({
        x: 0, y: 0,
        startX: 0, startY: 0,
        rowFrac,
        angleFrac: 0.5 - arcSpread + Math.random() * arcSpread * 2,
        targetX: 0, targetY: 0,
        progress: 0,
        convSpeed: 0.00015 + Math.random() * 0.0005,
        size: 0.3 + Math.random() * 1.0,
        baseAlpha: 0.04 + Math.random() * 0.11,
        phase: Math.random() * Math.PI * 2,
        pulseSpeed: 0.0005 + Math.random() * 0.0014,
        driftPhase: Math.random() * Math.PI * 2,
        driftSpeed: 0.0002 + Math.random() * 0.0005,
        driftAmp: 1.5 + Math.random() * 4,
        inited: false,
      });
    }

    function recalcTargets() {
      const cx = W * 0.5;
      const stageY = H * 0.38;
      const unit = Math.min(W, H) * 0.01;

      for (const s of souls) {
        const dist = (9 + s.rowFrac * 36) * unit;
        const angle = Math.PI * s.angleFrac;
        s.targetX = cx + Math.cos(angle) * dist;
        s.targetY = stageY + Math.sin(angle) * dist * 0.56;

        if (!s.inited) {
          s.startX = Math.random() * W;
          s.startY = Math.random() * H;
          s.x = s.startX;
          s.y = s.startY;
          s.inited = true;
        }
      }
    }

    resize();
    window.addEventListener('resize', resize);

    // === WHISPERS — connections between nearby seated souls ===
    const whispers = [];
    let whisperTimer = 0;

    function frame(ts) {
      ctx.fillStyle = '#07050f';
      ctx.fillRect(0, 0, W, H);

      const cx = W * 0.5;
      const stageY = H * 0.38;

      // Warm overhead wash
      const topLight = ctx.createRadialGradient(cx, H * 0.08, 0, cx, H * 0.08, H * 0.7);
      topLight.addColorStop(0, 'rgba(210, 165, 80, 0.022)');
      topLight.addColorStop(0.3, 'rgba(196, 148, 58, 0.009)');
      topLight.addColorStop(0.6, 'rgba(140, 90, 40, 0.003)');
      topLight.addColorStop(1, 'transparent');
      ctx.fillStyle = topLight;
      ctx.fillRect(0, 0, W, H);

      // Cool undertones in lower corners
      const coolL = ctx.createRadialGradient(W * 0.05, H * 0.95, 0, W * 0.05, H * 0.95, H * 0.45);
      coolL.addColorStop(0, 'rgba(40, 35, 75, 0.012)');
      coolL.addColorStop(1, 'transparent');
      ctx.fillStyle = coolL;
      ctx.fillRect(0, 0, W, H);

      const coolR = ctx.createRadialGradient(W * 0.95, H * 0.92, 0, W * 0.95, H * 0.92, H * 0.4);
      coolR.addColorStop(0, 'rgba(35, 30, 68, 0.01)');
      coolR.addColorStop(1, 'transparent');
      ctx.fillStyle = coolR;
      ctx.fillRect(0, 0, W, H);

      // === THE SPEAKER — warm beacon at stage center ===
      const spPulse = Math.sin(ts * 0.0007) * 0.5 + 0.5;
      const spRadius = 32 + spPulse * 16;

      // Outer glow
      const spGlow = ctx.createRadialGradient(cx, stageY, 0, cx, stageY, spRadius);
      spGlow.addColorStop(0, `rgba(245, 210, 135, ${0.2 + spPulse * 0.1})`);
      spGlow.addColorStop(0.12, `rgba(220, 178, 95, ${0.08 + spPulse * 0.05})`);
      spGlow.addColorStop(0.35, `rgba(196, 148, 58, ${0.02})`);
      spGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = spGlow;
      ctx.beginPath();
      ctx.arc(cx, stageY, spRadius, 0, Math.PI * 2);
      ctx.fill();

      // Core
      ctx.beginPath();
      ctx.arc(cx, stageY, 3.2, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 238, 185, ${0.55 + spPulse * 0.35})`;
      ctx.fill();

      // === COLLECTIVE BREATH — syncs as souls settle ===
      const collectivePulse = Math.sin(ts * 0.0004) * 0.5 + 0.5;

      // === SOULS — converging into amphitheater ===
      for (const s of souls) {
        s.progress = Math.min(1, s.progress + s.convSpeed);
        const t = s.progress * s.progress * (3 - 2 * s.progress); // smoothstep

        const drift = Math.sin(ts * s.driftSpeed + s.driftPhase) * s.driftAmp;
        const driftY = Math.cos(ts * s.driftSpeed * 0.7 + s.driftPhase) * s.driftAmp * 0.5;

        s.x = s.startX + (s.targetX - s.startX) * t + drift * t;
        s.y = s.startY + (s.targetY - s.startY) * t + driftY * t;

        const pulse = Math.sin(ts * s.pulseSpeed + s.phase) * 0.5 + 0.5;
        const alpha = s.baseAlpha * (0.18 + t * 0.4 + pulse * 0.22 + collectivePulse * 0.15 * t);

        // Blue (scattered) → amber (seated)
        const warmth = t * 0.65 + pulse * 0.12;
        const hue = 228 - warmth * 198;
        const sat = 24 + warmth * 42;
        const lit = 30 + warmth * 26 + pulse * 8;

        // Glow halo for brighter souls that have mostly settled
        if (s.size > 0.65 && alpha > 0.05 && t > 0.35) {
          const sg = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.size * 9);
          sg.addColorStop(0, `hsla(${hue}, ${sat}%, ${lit}%, ${alpha * 0.1})`);
          sg.addColorStop(1, 'transparent');
          ctx.fillStyle = sg;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.size * 9, 0, Math.PI * 2);
          ctx.fill();
        }

        // Core point
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${hue}, ${sat}%, ${lit}%, ${alpha})`;
        ctx.fill();
      }

      // === WHISPERS — fleeting links between nearby seated souls ===
      whisperTimer++;
      if (whisperTimer > 100) {
        whisperTimer = 0;
        const a = Math.floor(Math.random() * N);
        const b = Math.floor(Math.random() * N);
        if (a !== b && souls[a].progress > 0.65 && souls[b].progress > 0.65) {
          const dx = souls[a].x - souls[b].x;
          const dy = souls[a].y - souls[b].y;
          if (Math.hypot(dx, dy) < 75) {
            whispers.push({ a, b, life: 1, decay: 0.004 + Math.random() * 0.006 });
          }
        }
      }

      for (let i = whispers.length - 1; i >= 0; i--) {
        const w = whispers[i];
        w.life -= w.decay;
        if (w.life <= 0) { whispers.splice(i, 1); continue; }

        ctx.beginPath();
        ctx.moveTo(souls[w.a].x, souls[w.a].y);
        ctx.lineTo(souls[w.b].x, souls[w.b].y);
        ctx.strokeStyle = `rgba(196, 162, 105, ${w.life * 0.02})`;
        ctx.lineWidth = 0.35;
        ctx.stroke();
      }

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
  </script>
</body>
</html>