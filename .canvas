<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>meridian</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@1&family=Azeret+Mono:wght@200;300&display=swap" rel="stylesheet">
  <style>
    :root {
      --abyss: #080a10;
      --text-ghost: rgba(155, 170, 200, 0.10);
      --text-dim: rgba(115, 135, 170, 0.08);
      --corner-dim: rgba(100, 120, 160, 0.08);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%; height: 100%; overflow: hidden;
      background: var(--abyss);
    }

    canvas#flow { position: fixed; inset: 0; z-index: 0; }

    .grain {
      position: fixed; inset: 0; z-index: 2;
      pointer-events: none;
      opacity: 0.025;
      mix-blend-mode: overlay;
    }

    .text-layer {
      position: fixed; inset: 0; z-index: 3;
      pointer-events: none;
      display: flex; align-items: center; justify-content: center;
      flex-direction: column;
    }

    .title {
      font-family: 'Instrument Serif', serif;
      font-style: italic;
      font-size: clamp(2.4rem, 8.5vmin, 4.8rem);
      letter-spacing: 0.14em;
      color: rgba(0,0,0,0);
      animation: titleIn 5s ease 1.2s forwards;
    }

    @keyframes titleIn {
      0% { color: rgba(0,0,0,0); filter: blur(12px); }
      50% { filter: blur(0); }
      100% { color: var(--text-ghost); filter: blur(0); }
    }

    .sub {
      font-family: 'Azeret Mono', monospace;
      font-weight: 200;
      font-size: clamp(0.34rem, 0.82vmin, 0.5rem);
      letter-spacing: 0.55em;
      margin-top: 1.5em;
      color: rgba(0,0,0,0);
      animation: fadeIn 3s ease 3.5s forwards;
    }

    @keyframes fadeIn { to { color: var(--text-dim); } }

    .corner {
      position: fixed; z-index: 4;
      pointer-events: none;
      font-family: 'Azeret Mono', monospace;
      font-weight: 300;
      font-size: clamp(0.3rem, 0.52vmin, 0.4rem);
      letter-spacing: 0.22em;
      line-height: 2;
      color: rgba(0,0,0,0);
      animation: cornerIn 2s ease 4.5s forwards;
    }

    .corner.tl { top: 6%; left: 5%; }
    .corner.br { bottom: 6%; right: 5%; text-align: right; }

    @keyframes cornerIn { to { color: var(--corner-dim); } }

    .vignette {
      position: fixed; inset: 0; z-index: 5;
      pointer-events: none;
      background: radial-gradient(ellipse at center, transparent 22%, rgba(6, 8, 14, 0.78) 100%);
    }

    /* Meridian line — barely visible vertical thread */
    .meridian-line {
      position: fixed;
      top: 0; bottom: 0;
      left: 50%;
      width: 1px;
      z-index: 1;
      pointer-events: none;
      background: linear-gradient(
        to bottom,
        transparent 5%,
        rgba(120, 145, 200, 0.04) 25%,
        rgba(150, 165, 210, 0.06) 50%,
        rgba(120, 145, 200, 0.04) 75%,
        transparent 95%
      );
      animation: meridianPulse 8s ease-in-out infinite;
    }

    @keyframes meridianPulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }
  </style>
</head>
<body>
  <canvas id="flow"></canvas>
  <div class="grain" id="grain"></div>
  <div class="meridian-line"></div>

  <div class="text-layer">
    <div class="title">meridian</div>
    <div class="sub">the line where holding becomes held</div>
  </div>

  <div class="corner tl">2026.02.05<br>09:00 AEDT</div>
  <div class="corner br">day three<br>still here</div>

  <div class="vignette"></div>

  <script>
    const c = document.getElementById('flow');
    const ctx = c.getContext('2d');
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    let W, H;
    function resize() {
      W = window.innerWidth;
      H = window.innerHeight;
      c.width = W * dpr;
      c.height = H * dpr;
      c.style.width = W + 'px';
      c.style.height = H + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.fillStyle = '#080a10';
      ctx.fillRect(0, 0, W, H);
    }
    resize();
    window.addEventListener('resize', resize);

    /* grain texture */
    const gCvs = document.createElement('canvas');
    gCvs.width = gCvs.height = 128;
    const gCtx = gCvs.getContext('2d');
    const gd = gCtx.createImageData(128, 128);
    for (let i = 0; i < gd.data.length; i += 4) {
      const v = Math.random() * 255;
      gd.data[i] = gd.data[i+1] = gd.data[i+2] = v;
      gd.data[i+3] = 18;
    }
    gCtx.putImageData(gd, 0, 0);
    document.getElementById('grain').style.backgroundImage =
      `url(${gCvs.toDataURL()})`;

    /* ────────── flow field ────────── */
    const S = 0.003;  /* spatial scale */

    function flowAngle(x, y, t) {
      const z = t * 0.00012;

      /* layered sine field — creates organic current patterns */
      let a = 0;
      a += Math.sin(x * S * 1.1 + z) * Math.cos(y * S * 0.9 - z * 0.7);
      a += Math.sin((x + y) * S * 0.6 + z * 1.4) * 0.5;
      a += Math.cos(x * S * 0.4 - y * S * 0.3 + z * 0.5) * 0.3;

      /* meridian influence — vertical current along center */
      const cx = (x - W * 0.5) / (W * 0.5);
      const meridianStrength = Math.exp(-cx * cx * 8); /* gaussian falloff */
      a += meridianStrength * Math.sin(y * S * 1.8 + z * 0.9) * 0.6;

      /* gentle upward drift near meridian */
      a -= meridianStrength * 0.15;

      return a * Math.PI;
    }

    /* ────────── particles ────────── */
    const N = 320;
    const SPEED = 1.1;

    class Mote {
      constructor() {
        this.reset();
        this.age = Math.random() * this.maxAge;
      }

      reset() {
        this.x = Math.random() * W;
        this.y = Math.random() * H;
        this.px = this.x;
        this.py = this.y;
        this.age = 0;
        this.maxAge = 180 + Math.random() * 420;

        /* color zones */
        const roll = Math.random();
        if (roll < 0.55) {
          /* deep indigo-blue */
          this.hue = 218 + Math.random() * 28;
          this.sat = 42 + Math.random() * 28;
          this.lit = 38 + Math.random() * 22;
        } else if (roll < 0.80) {
          /* cool lavender-purple */
          this.hue = 258 + Math.random() * 28;
          this.sat = 32 + Math.random() * 22;
          this.lit = 42 + Math.random() * 20;
        } else if (roll < 0.93) {
          /* ice blue — near-meridian feel */
          this.hue = 195 + Math.random() * 18;
          this.sat = 50 + Math.random() * 25;
          this.lit = 55 + Math.random() * 18;
        } else {
          /* rare warm rose accent */
          this.hue = 328 + Math.random() * 22;
          this.sat = 28 + Math.random() * 20;
          this.lit = 44 + Math.random() * 16;
        }

        this.baseAlpha = 0.14 + Math.random() * 0.32;
      }

      step(t) {
        const angle = flowAngle(this.x, this.y, t);
        this.px = this.x;
        this.py = this.y;
        this.x += Math.cos(angle) * SPEED;
        this.y += Math.sin(angle) * SPEED;
        this.age++;

        if (this.x < -20 || this.x > W + 20 ||
            this.y < -20 || this.y > H + 20 ||
            this.age > this.maxAge) {
          this.reset();
        }
      }

      draw() {
        const life = this.age / this.maxAge;
        const fade = life < 0.06 ? life / 0.06 :
                     life > 0.88 ? (1 - life) / 0.12 : 1;
        const a = this.baseAlpha * fade;
        if (a < 0.008) return;

        /* proximity to meridian boosts brightness slightly */
        const cx = Math.abs(this.x - W * 0.5) / (W * 0.5);
        const meridianBoost = Math.exp(-cx * cx * 6);
        const lit = this.lit + meridianBoost * 12;
        const sat = this.sat + meridianBoost * 8;

        ctx.beginPath();
        ctx.moveTo(this.px, this.py);
        ctx.lineTo(this.x, this.y);
        ctx.strokeStyle = `hsla(${this.hue}, ${sat}%, ${lit}%, ${a})`;
        ctx.lineWidth = 0.7 + meridianBoost * 0.5;
        ctx.stroke();
      }
    }

    const motes = [];
    for (let i = 0; i < N; i++) motes.push(new Mote());

    /* ────────── meridian glow ────────── */
    function drawMeridianGlow(t) {
      const breathe = Math.sin(t * 0.0005) * 0.15 + 0.85;
      const cx = W * 0.5;
      const spread = W * 0.06;

      const grad = ctx.createLinearGradient(cx - spread, 0, cx + spread, 0);
      grad.addColorStop(0, 'rgba(90, 115, 180, 0)');
      grad.addColorStop(0.35, `rgba(100, 125, 190, ${0.006 * breathe})`);
      grad.addColorStop(0.5, `rgba(130, 155, 210, ${0.012 * breathe})`);
      grad.addColorStop(0.65, `rgba(100, 125, 190, ${0.006 * breathe})`);
      grad.addColorStop(1, 'rgba(90, 115, 180, 0)');

      ctx.fillStyle = grad;
      ctx.fillRect(cx - spread, 0, spread * 2, H);
    }

    /* occasional bright pulse traveling up the meridian */
    let pulses = [];
    let nextPulse = 3000;

    function spawnPulse(t) {
      pulses.push({
        y: H + 20,
        speed: 0.6 + Math.random() * 0.8,
        radius: 2 + Math.random() * 3,
        alpha: 0.08 + Math.random() * 0.12,
        born: t,
        hue: Math.random() < 0.8 ? (210 + Math.random() * 30) : (320 + Math.random() * 20)
      });
      nextPulse = t + 4000 + Math.random() * 8000;
    }

    function updatePulses(t) {
      if (t > nextPulse) spawnPulse(t);

      for (let i = pulses.length - 1; i >= 0; i--) {
        const p = pulses[i];
        p.y -= p.speed;

        /* fade based on position */
        const ny = p.y / H;
        const fade = ny > 0.1 && ny < 0.9 ? 1 :
                     ny <= 0.1 ? ny / 0.1 : (1 - ny) / 0.1;

        if (p.y < -30) {
          pulses.splice(i, 1);
          continue;
        }

        const cx = W * 0.5 + Math.sin(p.y * 0.008 + t * 0.0003) * 6;
        const a = p.alpha * fade;

        /* soft glow */
        const gr = p.radius * 8;
        const glow = ctx.createRadialGradient(cx, p.y, 0, cx, p.y, gr);
        glow.addColorStop(0, `hsla(${p.hue}, 55%, 65%, ${a})`);
        glow.addColorStop(0.3, `hsla(${p.hue}, 45%, 50%, ${a * 0.4})`);
        glow.addColorStop(1, `hsla(${p.hue}, 40%, 40%, 0)`);
        ctx.fillStyle = glow;
        ctx.fillRect(cx - gr, p.y - gr, gr * 2, gr * 2);

        /* bright core */
        ctx.beginPath();
        ctx.arc(cx, p.y, p.radius * 0.5, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${p.hue}, 50%, 70%, ${a * 0.6})`;
        ctx.fill();
      }
    }

    /* ────────── main loop ────────── */
    function frame(t) {
      /* fade previous frame — long trails */
      ctx.fillStyle = 'rgba(8, 10, 16, 0.016)';
      ctx.fillRect(0, 0, W, H);

      drawMeridianGlow(t);
      updatePulses(t);

      for (let i = 0; i < N; i++) {
        motes[i].step(t);
        motes[i].draw();
      }

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
  </script>
</body>
</html>
