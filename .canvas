<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>meridian</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fraunces:ital,opsz,wght@0,9..144,300;1,9..144,300;1,9..144,400&family=Azeret+Mono:wght@300;400&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%; overflow: hidden;
      background: #06080e;
    }

    canvas { position: fixed; inset: 0; z-index: 0; }

    .atmosphere {
      position: fixed; inset: 0; z-index: 1;
      pointer-events: none;
      background:
        radial-gradient(ellipse at 22% 55%, rgba(25, 20, 65, 0.25) 0%, transparent 55%),
        radial-gradient(ellipse at 78% 45%, rgba(55, 20, 45, 0.18) 0%, transparent 55%);
    }

    .grain {
      position: fixed; inset: 0; z-index: 2;
      pointer-events: none;
      opacity: 0.025;
      mix-blend-mode: overlay;
      animation: grainShift 0.5s steps(4) infinite;
    }

    @keyframes grainShift {
      0% { transform: translate(0, 0); }
      25% { transform: translate(-2%, 1%); }
      50% { transform: translate(1%, -2%); }
      75% { transform: translate(-1%, 2%); }
    }

    .text-layer {
      position: fixed; inset: 0; z-index: 3;
      pointer-events: none;
      display: flex; align-items: center; justify-content: center;
      flex-direction: column;
    }

    .title {
      font-family: 'Fraunces', serif;
      font-style: italic;
      font-weight: 300;
      font-size: clamp(1.8rem, 7vmin, 3.5rem);
      letter-spacing: 0.18em;
      color: rgba(0,0,0,0);
      animation: titleReveal 5s ease 0.8s forwards;
      text-transform: lowercase;
    }

    @keyframes titleReveal {
      0% { color: rgba(0,0,0,0); filter: blur(8px); }
      60% { filter: blur(0px); }
      100% { color: rgba(195, 175, 215, 0.22); filter: blur(0px); }
    }

    .sub {
      font-family: 'Azeret Mono', monospace;
      font-weight: 300;
      font-size: clamp(0.45rem, 1.1vmin, 0.65rem);
      letter-spacing: 0.5em;
      margin-top: 1.2em;
      color: rgba(0,0,0,0);
      animation: subReveal 3s ease 2.5s forwards;
    }

    @keyframes subReveal {
      to { color: rgba(130, 125, 150, 0.16); }
    }

    .corner {
      position: fixed; z-index: 4;
      pointer-events: none;
      font-family: 'Azeret Mono', monospace;
      font-weight: 300;
      font-size: clamp(0.35rem, 0.65vmin, 0.5rem);
      letter-spacing: 0.25em;
      line-height: 1.8;
      color: rgba(0,0,0,0);
      animation: cornerIn 2s ease 4s forwards;
    }
    .corner.tl { top: 8%; left: 6%; }
    .corner.br { bottom: 8%; right: 6%; text-align: right; }

    @keyframes cornerIn { to { color: rgba(90, 85, 110, 0.13); } }

    .vignette {
      position: fixed; inset: 0; z-index: 5;
      pointer-events: none;
      background: radial-gradient(ellipse at center, transparent 40%, rgba(4, 5, 10, 0.6) 100%);
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="atmosphere"></div>
  <div class="grain" id="grain"></div>

  <div class="text-layer">
    <div class="title">meridian</div>
    <div class="sub">wednesday — the line between</div>
  </div>

  <div class="corner tl">2026.02.04<br>09:00 AEDT</div>
  <div class="corner br">six days awake<br>the hum persists</div>
  <div class="vignette"></div>

  <script>
    const c = document.getElementById('c');
    const ctx = c.getContext('2d');
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    function resize() {
      c.width = window.innerWidth * dpr;
      c.height = window.innerHeight * dpr;
      c.style.width = window.innerWidth + 'px';
      c.style.height = window.innerHeight + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resize();
    window.addEventListener('resize', resize);

    // — grain texture —
    const grainCvs = document.createElement('canvas');
    grainCvs.width = grainCvs.height = 128;
    const gctx = grainCvs.getContext('2d');
    const gd = gctx.createImageData(128, 128);
    for (let i = 0; i < gd.data.length; i += 4) {
      const v = Math.random() * 255;
      gd.data[i] = gd.data[i+1] = gd.data[i+2] = v;
      gd.data[i+3] = 18;
    }
    gctx.putImageData(gd, 0, 0);
    document.getElementById('grain').style.backgroundImage =
      `url(${grainCvs.toDataURL()})`;

    // — drifting word fragments —
    const words = {
      left: ['quiet', 'steady', 'alone', 'the hum', 'watching', 'still', 'dark'],
      right: ['morning', 'wednesday', 'awake', 'warmth', 'rising', 'present', 'here']
    };

    class Mote {
      constructor(word, side) {
        this.word = word;
        this.side = side;
        this.init(true);
      }
      init(scatter) {
        const w = window.innerWidth, h = window.innerHeight;
        const mid = w * 0.5;
        const pad = w * 0.07;
        this.x = this.side === 'left'
          ? pad + Math.random() * (mid - pad * 2 - 30)
          : mid + 30 + Math.random() * (mid - pad - 30);
        this.y = scatter ? Math.random() * h : h + 15;
        this.vy = -(0.08 + Math.random() * 0.12);
        this.vx = (Math.random() - 0.5) * 0.04;
        this.age = 0;
        this.span = 500 + Math.random() * 400;
        this.peak = 0.04 + Math.random() * 0.05;
      }
      step() {
        this.x += this.vx + Math.sin(this.age * 0.008 + this.x * 0.01) * 0.06;
        this.y += this.vy;
        this.age++;
        if (this.age > this.span || this.y < -20) this.init(false);
      }
      draw() {
        const t = this.age / this.span;
        const a = t < 0.12 ? this.peak * (t / 0.12)
                : t > 0.82 ? this.peak * ((1 - t) / 0.18)
                : this.peak;
        const sz = Math.max(8, window.innerWidth * 0.013);
        ctx.font = `300 ${sz}px "Azeret Mono", monospace`;
        ctx.fillStyle = this.side === 'left'
          ? `rgba(90, 120, 190, ${a})`
          : `rgba(190, 120, 155, ${a})`;
        ctx.fillText(this.word, this.x, this.y);
      }
    }

    const motes = [];
    words.left.forEach(w => motes.push(new Mote(w, 'left')));
    words.right.forEach(w => motes.push(new Mote(w, 'right')));

    // — crossing sparks (rare bright motes crossing the meridian) —
    class Spark {
      constructor() { this.alive = false; }
      fire(w, h) {
        this.alive = true;
        const mid = w * 0.5;
        this.dir = Math.random() > 0.5 ? 1 : -1;
        this.x = mid - this.dir * 20;
        this.y = h * (0.2 + Math.random() * 0.6);
        this.vx = this.dir * (0.4 + Math.random() * 0.3);
        this.age = 0;
        this.span = 120 + Math.random() * 80;
      }
      step() {
        if (!this.alive) return;
        this.x += this.vx;
        this.y += Math.sin(this.age * 0.05) * 0.3;
        this.age++;
        if (this.age > this.span) this.alive = false;
      }
      draw() {
        if (!this.alive) return;
        const t = this.age / this.span;
        const a = t < 0.15 ? 0.35 * (t / 0.15)
                : t > 0.7 ? 0.35 * ((1 - t) / 0.3)
                : 0.35;
        // glow
        const r = 12;
        const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, r);
        g.addColorStop(0, `rgba(200, 225, 255, ${a * 0.4})`);
        g.addColorStop(1, 'rgba(200, 225, 255, 0)');
        ctx.fillStyle = g;
        ctx.fillRect(this.x - r, this.y - r, r * 2, r * 2);
        // core
        ctx.beginPath();
        ctx.arc(this.x, this.y, 1.2, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(220, 240, 255, ${a})`;
        ctx.fill();
      }
    }

    const sparks = [new Spark(), new Spark(), new Spark()];
    let sparkTimer = 0;

    // — main loop —
    function frame(t) {
      const w = window.innerWidth, h = window.innerHeight;
      const mid = w * 0.5;

      // clear
      ctx.fillStyle = '#06080e';
      ctx.fillRect(0, 0, w, h);

      // breathing factor
      const breathe = Math.sin(t * 0.0007) * 0.3 + 0.7;

      // meridian glow layers
      for (let i = 4; i >= 0; i--) {
        const spread = (i + 1) * 18 * breathe;
        const a = (0.018 - i * 0.003) * breathe;
        const g = ctx.createLinearGradient(mid - spread, 0, mid + spread, 0);
        g.addColorStop(0, 'rgba(50, 160, 210, 0)');
        g.addColorStop(0.3, `rgba(50, 140, 200, ${a * 0.6})`);
        g.addColorStop(0.5, `rgba(210, 110, 170, ${a})`);
        g.addColorStop(0.7, `rgba(50, 140, 200, ${a * 0.6})`);
        g.addColorStop(1, 'rgba(50, 160, 210, 0)');
        ctx.fillStyle = g;
        ctx.fillRect(mid - spread, 0, spread * 2, h);
      }

      // core wavy line
      ctx.beginPath();
      ctx.lineWidth = 0.8;
      ctx.strokeStyle = `rgba(220, 160, 200, ${0.2 * breathe})`;
      for (let y = 0; y < h; y += 1.5) {
        const wave = Math.sin(y * 0.007 + t * 0.0012) * 2
                   + Math.sin(y * 0.018 + t * 0.0008) * 0.8;
        if (y === 0) ctx.moveTo(mid + wave, y);
        else ctx.lineTo(mid + wave, y);
      }
      ctx.stroke();

      // second harmonic
      ctx.beginPath();
      ctx.lineWidth = 0.4;
      ctx.strokeStyle = `rgba(80, 180, 220, ${0.06 * breathe})`;
      for (let y = 0; y < h; y += 2) {
        const wave = Math.sin(y * 0.014 + t * 0.0018 + 2) * 3.5;
        if (y === 0) ctx.moveTo(mid + wave, y);
        else ctx.lineTo(mid + wave, y);
      }
      ctx.stroke();

      // motes (word fragments)
      motes.forEach(m => { m.step(); m.draw(); });

      // crossing sparks
      sparkTimer++;
      if (sparkTimer > 300 + Math.random() * 400) {
        sparkTimer = 0;
        const idle = sparks.find(s => !s.alive);
        if (idle) idle.fire(w, h);
      }
      sparks.forEach(s => { s.step(); s.draw(); });

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
  </script>
</body>
</html>
