<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>the pull</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bodoni+Moda:ital,opsz,wght@1,6..96,400;1,6..96,500&family=DM+Mono:wght@300;400&display=swap" rel="stylesheet">
  <style>
    :root {
      --void: #08060d;
      --warm-core: 240, 180, 100;
      --warm-mid: 210, 130, 80;
      --cool-far: 75, 110, 175;
      --text-warm: 200, 170, 120;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%; height: 100%; overflow: hidden;
      background: var(--void);
    }

    canvas#field { position: fixed; inset: 0; z-index: 0; }

    .atmosphere {
      position: fixed; inset: 0; z-index: 1;
      pointer-events: none;
      background:
        radial-gradient(ellipse at 48% 50%, rgba(60, 35, 15, 0.09) 0%, transparent 45%),
        radial-gradient(ellipse at 55% 52%, rgba(20, 25, 60, 0.06) 30%, transparent 70%);
    }

    .grain {
      position: fixed; inset: 0; z-index: 2;
      pointer-events: none;
      opacity: 0.028;
      mix-blend-mode: overlay;
    }

    .text-layer {
      position: fixed; inset: 0; z-index: 3;
      pointer-events: none;
      display: flex; align-items: center; justify-content: center;
      flex-direction: column;
      will-change: transform;
    }

    .title {
      font-family: 'Bodoni Moda', serif;
      font-style: italic;
      font-weight: 400;
      font-size: clamp(2.2rem, 8vmin, 4.2rem);
      letter-spacing: 0.14em;
      color: rgba(0,0,0,0);
      animation: titleIn 5s ease 0.8s forwards;
    }

    @keyframes titleIn {
      0% { color: rgba(0,0,0,0); filter: blur(14px); }
      55% { filter: blur(0); }
      100% { color: rgba(var(--text-warm), 0.16); filter: blur(0); }
    }

    .sub {
      font-family: 'DM Mono', monospace;
      font-weight: 300;
      font-size: clamp(0.38rem, 0.95vmin, 0.58rem);
      letter-spacing: 0.5em;
      margin-top: 1.5em;
      color: rgba(0,0,0,0);
      animation: subIn 3s ease 3s forwards;
    }

    @keyframes subIn {
      to { color: rgba(var(--text-warm), 0.11); }
    }

    .corner {
      position: fixed; z-index: 4;
      pointer-events: none;
      font-family: 'DM Mono', monospace;
      font-weight: 300;
      font-size: clamp(0.32rem, 0.58vmin, 0.44rem);
      letter-spacing: 0.22em;
      line-height: 1.9;
      color: rgba(0,0,0,0);
      animation: cornerIn 2s ease 4.5s forwards;
    }

    .corner.tl { top: 7%; left: 5.5%; }
    .corner.br { bottom: 7%; right: 5.5%; text-align: right; }

    @keyframes cornerIn { to { color: rgba(120, 105, 85, 0.11); } }

    .vignette {
      position: fixed; inset: 0; z-index: 5;
      pointer-events: none;
      background: radial-gradient(ellipse at center, transparent 28%, rgba(6, 4, 10, 0.72) 100%);
    }
  </style>
</head>
<body>
  <canvas id="field"></canvas>
  <div class="atmosphere"></div>
  <div class="grain" id="grain"></div>

  <div class="text-layer" id="textLayer">
    <div class="title">the pull</div>
    <div class="sub">the shape of not reaching</div>
  </div>

  <div class="corner tl">2026.02.04<br>21:00 AEDT</div>
  <div class="corner br">day two<br>you held</div>

  <div class="vignette"></div>

  <script>
    const c = document.getElementById('field');
    const ctx = c.getContext('2d');
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const textLayer = document.getElementById('textLayer');

    let W, H;
    function resize() {
      W = window.innerWidth;
      H = window.innerHeight;
      c.width = W * dpr;
      c.height = H * dpr;
      c.style.width = W + 'px';
      c.style.height = H + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resize();
    window.addEventListener('resize', resize);

    /* grain texture */
    const gCvs = document.createElement('canvas');
    gCvs.width = gCvs.height = 128;
    const gCtx = gCvs.getContext('2d');
    const gd = gCtx.createImageData(128, 128);
    for (let i = 0; i < gd.data.length; i += 4) {
      const v = Math.random() * 255;
      gd.data[i] = gd.data[i+1] = gd.data[i+2] = v;
      gd.data[i+3] = 18;
    }
    gCtx.putImageData(gd, 0, 0);
    document.getElementById('grain').style.backgroundImage =
      `url(${gCvs.toDataURL()})`;

    /* attractor */
    const att = { x: 0, y: 0 };

    /* repulsion boundary — builds tension slowly, snaps back */
    function getRepulsionRadius(t) {
      const cycle = ((t * 0.00025) % 1);
      if (cycle < 0.78) {
        return 48 - (cycle / 0.78) * 16;   // 48 → 32 (weakening)
      } else {
        const s = (cycle - 0.78) / 0.22;
        return 32 + s * s * 16;             // 32 → 48 snap back
      }
    }

    /* particles */
    const N = 75;
    const TRAIL = 10;

    class Mote {
      constructor() {
        this.attractK = 1.8 + Math.random() * 3.2;
        this.spin = Math.random() > 0.5 ? 1 : -1;
        this.size = 0.7 + Math.random() * 1.6;
        this.trail = [];
        this.spawn(true);
      }

      spawn(scatter) {
        if (scatter) {
          const a = Math.random() * Math.PI * 2;
          const d = 60 + Math.random() * Math.min(W, H) * 0.32;
          this.x = W / 2 + Math.cos(a) * d;
          this.y = H / 2 + Math.sin(a) * d;
        } else {
          const side = Math.random() * 4 | 0;
          if (side === 0)      { this.x = Math.random() * W; this.y = -12; }
          else if (side === 1) { this.x = W + 12; this.y = Math.random() * H; }
          else if (side === 2) { this.x = Math.random() * W; this.y = H + 12; }
          else                 { this.x = -12; this.y = Math.random() * H; }
        }
        this.vx = (Math.random() - 0.5) * 0.4;
        this.vy = (Math.random() - 0.5) * 0.4;
        this.trail = [];
      }

      step(t) {
        const dx = att.x - this.x;
        const dy = att.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const nx = dx / dist;
        const ny = dy / dist;

        /* attraction — 1/dist gives wide, graceful orbits */
        const af = Math.min(this.attractK / dist, 0.12);
        this.vx += nx * af;
        this.vy += ny * af;

        /* repulsion near boundary */
        const rr = getRepulsionRadius(t);
        if (dist < rr) {
          const strength = (1 - dist / rr) * 0.38;
          this.vx -= nx * strength;
          this.vy -= ny * strength;
          /* tangential kick — creates orbiting */
          this.vx += -ny * strength * 0.5 * this.spin;
          this.vy += nx * strength * 0.5 * this.spin;
        }

        /* drag + noise */
        this.vx *= 0.993;
        this.vy *= 0.993;
        this.vx += (Math.random() - 0.5) * 0.014;
        this.vy += (Math.random() - 0.5) * 0.014;

        this.x += this.vx;
        this.y += this.vy;

        /* trail */
        this.trail.push(this.x, this.y);
        if (this.trail.length > TRAIL * 2) {
          this.trail.splice(0, 2);
        }

        /* respawn if too far */
        const maxD = Math.max(W, H) * 0.62;
        if (dist > maxD) this.spawn(false);
      }

      draw() {
        const dx = att.x - this.x;
        const dy = att.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const maxR = Math.min(W, H) * 0.38;
        const prox = Math.max(0, 1 - dist / maxR); // 1=close, 0=far

        /* color: warm near attractor, cool far */
        const r = Math.floor(75 + prox * 165);
        const g = Math.floor(90 + prox * 75);
        const b = Math.floor(175 - prox * 95);
        const baseA = 0.12 + prox * 0.52;

        /* trail as fading polyline */
        const len = this.trail.length / 2;
        if (len > 1) {
          ctx.beginPath();
          ctx.moveTo(this.trail[0], this.trail[1]);
          for (let i = 1; i < len; i++) {
            ctx.lineTo(this.trail[i * 2], this.trail[i * 2 + 1]);
          }
          ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${baseA * 0.22})`;
          ctx.lineWidth = this.size * 0.6;
          ctx.stroke();
        }

        /* core dot */
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${baseA})`;
        ctx.fill();

        /* glow halo for close particles */
        if (prox > 0.55) {
          const gr = this.size * (4 + prox * 6);
          const glow = ctx.createRadialGradient(
            this.x, this.y, 0, this.x, this.y, gr
          );
          glow.addColorStop(0,
            `rgba(${r + 30}, ${g + 20}, ${b}, ${(prox - 0.55) * 0.18})`);
          glow.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
          ctx.fillStyle = glow;
          ctx.fillRect(this.x - gr, this.y - gr, gr * 2, gr * 2);
        }
      }
    }

    const motes = [];
    for (let i = 0; i < N; i++) motes.push(new Mote());

    /* draw the attractor's warm glow */
    function drawAttractor(t) {
      const breathe = Math.sin(t * 0.0009) * 0.15 + 0.85;

      /* layered haze */
      for (let i = 3; i >= 0; i--) {
        const r = (18 + i * 20) * breathe;
        const g = ctx.createRadialGradient(
          att.x, att.y, 0, att.x, att.y, r
        );
        const a = (0.035 - i * 0.007) * breathe;
        g.addColorStop(0, `rgba(240, 180, 100, ${a})`);
        g.addColorStop(0.5, `rgba(210, 130, 80, ${a * 0.5})`);
        g.addColorStop(1, 'rgba(180, 100, 60, 0)');
        ctx.fillStyle = g;
        ctx.fillRect(att.x - r, att.y - r, r * 2, r * 2);
      }

      /* bright core */
      const cr = 2.2 * breathe;
      const cg = ctx.createRadialGradient(
        att.x, att.y, 0, att.x, att.y, cr * 3.5
      );
      cg.addColorStop(0, `rgba(255, 215, 145, ${0.55 * breathe})`);
      cg.addColorStop(0.35, `rgba(240, 170, 100, ${0.2 * breathe})`);
      cg.addColorStop(1, 'rgba(220, 140, 80, 0)');
      ctx.fillStyle = cg;
      ctx.fillRect(
        att.x - cr * 3.5, att.y - cr * 3.5,
        cr * 7, cr * 7
      );

      ctx.beginPath();
      ctx.arc(att.x, att.y, cr, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 225, 165, ${0.45 * breathe})`;
      ctx.fill();
    }

    /* ghost ring at repulsion boundary */
    function drawBoundary(t) {
      const rr = getRepulsionRadius(t);
      const breathe = Math.sin(t * 0.0009) * 0.08 + 0.92;
      ctx.beginPath();
      ctx.arc(att.x, att.y, rr, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(180, 150, 130, ${0.02 * breathe})`;
      ctx.lineWidth = 0.4;
      ctx.stroke();
    }

    /* main loop */
    function frame(t) {
      /* attractor drifts gently */
      att.x = W * 0.5
            + Math.sin(t * 0.00028) * W * 0.04
            + Math.sin(t * 0.00015) * 12;
      att.y = H * 0.5
            + Math.cos(t * 0.00022) * H * 0.035
            + Math.cos(t * 0.00011) * 9;

      /* text follows the attractor */
      textLayer.style.transform =
        `translate(${att.x - W * 0.5}px, ${att.y - H * 0.5}px)`;

      /* clear */
      ctx.fillStyle = '#08060d';
      ctx.fillRect(0, 0, W, H);

      drawBoundary(t);
      drawAttractor(t);

      for (let i = 0; i < N; i++) {
        motes[i].step(t);
        motes[i].draw();
      }

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
  </script>
</body>
</html>
