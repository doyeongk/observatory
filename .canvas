<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>interference</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
  background: #0a0a0f; 
  overflow: hidden; 
  cursor: crosshair;
}
canvas { display: block; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let w, h, cx, cy;
let mouseX, mouseY;
let time = 0;

// Pattern centers - they drift slowly
let centers = [
  { x: 0.3, y: 0.4, vx: 0.0001, vy: 0.00015, phase: 0 },
  { x: 0.7, y: 0.6, vx: -0.00012, vy: 0.0001, phase: Math.PI * 0.5 },
  { x: 0.5, y: 0.3, vx: 0.00008, vy: -0.00013, phase: Math.PI }
];

function resize() {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
  cx = w / 2;
  cy = h / 2;
  mouseX = cx;
  mouseY = cy;
}

window.addEventListener('resize', resize);
canvas.addEventListener('mousemove', e => {
  mouseX = e.clientX;
  mouseY = e.clientY;
});
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  mouseX = e.touches[0].clientX;
  mouseY = e.touches[0].clientY;
}, { passive: false });

resize();

function drawConcentricRings(centerX, centerY, rotation, lineCount, color, alpha) {
  ctx.save();
  ctx.translate(centerX, centerY);
  ctx.rotate(rotation);
  
  const maxRadius = Math.sqrt(w * w + h * h);
  const spacing = 12;
  
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.globalAlpha = alpha;
  
  for (let r = spacing; r < maxRadius; r += spacing) {
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  ctx.restore();
}

function drawRadialLines(centerX, centerY, rotation, lineCount, color, alpha) {
  ctx.save();
  ctx.translate(centerX, centerY);
  ctx.rotate(rotation);
  
  const maxRadius = Math.sqrt(w * w + h * h);
  
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;
  ctx.globalAlpha = alpha;
  
  for (let i = 0; i < lineCount; i++) {
    const angle = (i / lineCount) * Math.PI * 2;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(Math.cos(angle) * maxRadius, Math.sin(angle) * maxRadius);
    ctx.stroke();
  }
  
  ctx.restore();
}

function drawParallelLines(centerX, centerY, rotation, spacing, color, alpha) {
  ctx.save();
  ctx.translate(centerX, centerY);
  ctx.rotate(rotation);
  
  const maxDist = Math.sqrt(w * w + h * h);
  
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;
  ctx.globalAlpha = alpha;
  
  for (let d = -maxDist; d < maxDist; d += spacing) {
    ctx.beginPath();
    ctx.moveTo(d, -maxDist);
    ctx.lineTo(d, maxDist);
    ctx.stroke();
  }
  
  ctx.restore();
}

function animate() {
  // Fade trail
  ctx.fillStyle = 'rgba(10, 10, 15, 0.15)';
  ctx.fillRect(0, 0, w, h);
  
  time += 0.003;
  
  // Update drifting centers
  centers.forEach((c, i) => {
    c.x += c.vx;
    c.y += c.vy;
    
    // Bounce off edges
    if (c.x < 0.1 || c.x > 0.9) c.vx *= -1;
    if (c.y < 0.1 || c.y > 0.9) c.vy *= -1;
  });
  
  // Mouse influence on one center
  const mouseInfluence = 0.05;
  centers[0].x += (mouseX / w - centers[0].x) * mouseInfluence;
  centers[0].y += (mouseY / h - centers[0].y) * mouseInfluence;
  
  // Pattern 1: Cyan concentric rings, slowly rotating
  drawConcentricRings(
    centers[0].x * w,
    centers[0].y * h,
    time * 0.3,
    60,
    '#00ffff',
    0.4
  );
  
  // Pattern 2: Magenta concentric rings, counter-rotating
  drawConcentricRings(
    centers[1].x * w,
    centers[1].y * h,
    -time * 0.25 + 0.02,
    60,
    '#ff00ff',
    0.35
  );
  
  // Pattern 3: Parallel lines, slowly rotating
  const breathe = Math.sin(time * 0.5) * 3;
  drawParallelLines(
    centers[2].x * w,
    centers[2].y * h,
    time * 0.15 + Math.PI / 4,
    10 + breathe,
    '#9933ff',
    0.3
  );
  
  // Pattern 4: Radial lines from mouse position
  drawRadialLines(
    mouseX,
    mouseY,
    time * 0.1,
    72,
    '#ff66aa',
    0.25
  );
  
  // Subtle vignette
  const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(w, h) * 0.7);
  gradient.addColorStop(0, 'rgba(10, 10, 15, 0)');
  gradient.addColorStop(1, 'rgba(10, 10, 15, 0.6)');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, w, h);
  
  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
