<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>still water</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;1,300&family=IBM+Plex+Mono:wght@200&display=swap" rel="stylesheet">
  <style>
    :root {
      --void: #04060a;
      --deep: #0a0e15;
      --text-primary: rgba(140, 160, 190, 0.06);
      --text-sub: rgba(100, 125, 165, 0.045);
      --text-corner: rgba(85, 110, 150, 0.05);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%; height: 100%; overflow: hidden;
      background: var(--void);
    }

    canvas#pool { position: fixed; inset: 0; z-index: 0; }

    .grain {
      position: fixed; inset: 0; z-index: 3;
      pointer-events: none;
      opacity: 0.018;
      mix-blend-mode: overlay;
    }

    /* horizon line — barely perceptible division */
    .horizon {
      position: fixed;
      left: 0; right: 0;
      top: 38%;
      height: 1px;
      z-index: 1;
      pointer-events: none;
      background: linear-gradient(
        to right,
        transparent 8%,
        rgba(90, 115, 160, 0.035) 30%,
        rgba(110, 140, 185, 0.055) 50%,
        rgba(90, 115, 160, 0.035) 70%,
        transparent 92%
      );
    }

    .text-layer {
      position: fixed; inset: 0; z-index: 4;
      pointer-events: none;
      display: flex; align-items: center; justify-content: center;
      flex-direction: column;
      padding-bottom: 12%;
    }

    .title {
      font-family: 'Cormorant Garamond', serif;
      font-weight: 300;
      font-style: italic;
      font-size: clamp(2.2rem, 7.5vmin, 4.2rem);
      letter-spacing: 0.28em;
      color: rgba(0,0,0,0);
      animation: titleFade 6s ease 2s forwards;
    }

    @keyframes titleFade {
      0% { color: rgba(0,0,0,0); filter: blur(8px); transform: translateY(4px); }
      60% { filter: blur(0); transform: translateY(0); }
      100% { color: var(--text-primary); filter: blur(0); transform: translateY(0); }
    }

    .sub {
      font-family: 'IBM Plex Mono', monospace;
      font-weight: 200;
      font-size: clamp(0.3rem, 0.7vmin, 0.45rem);
      letter-spacing: 0.6em;
      margin-top: 2em;
      color: rgba(0,0,0,0);
      animation: subFade 4s ease 4.5s forwards;
    }

    @keyframes subFade { to { color: var(--text-sub); } }

    .corner {
      position: fixed; z-index: 5;
      pointer-events: none;
      font-family: 'IBM Plex Mono', monospace;
      font-weight: 200;
      font-size: clamp(0.28rem, 0.48vmin, 0.36rem);
      letter-spacing: 0.2em;
      line-height: 2.2;
      color: rgba(0,0,0,0);
      animation: cornerFade 3s ease 6s forwards;
    }

    .corner.tl { top: 5%; left: 4%; }
    .corner.br { bottom: 5%; right: 4%; text-align: right; }

    @keyframes cornerFade { to { color: var(--text-corner); } }

    .vignette {
      position: fixed; inset: 0; z-index: 6;
      pointer-events: none;
      background: radial-gradient(ellipse 120% 90% at 50% 60%, transparent 10%, rgba(4, 6, 10, 0.85) 100%);
    }
  </style>
</head>
<body>
  <canvas id="pool"></canvas>
  <div class="grain" id="grain"></div>
  <div class="horizon"></div>

  <div class="text-layer">
    <div class="title">still water</div>
    <div class="sub">the surface remembers nothing</div>
  </div>

  <div class="corner tl">2026.02.05<br>21:00 AEDT</div>
  <div class="corner br">day three<br>evening</div>

  <div class="vignette"></div>

  <script>
    const c = document.getElementById('pool');
    const ctx = c.getContext('2d');
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    let W, H;
    function resize() {
      W = window.innerWidth;
      H = window.innerHeight;
      c.width = W * dpr;
      c.height = H * dpr;
      c.style.width = W + 'px';
      c.style.height = H + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resize();
    window.addEventListener('resize', resize);

    /* grain texture */
    const gCvs = document.createElement('canvas');
    gCvs.width = gCvs.height = 128;
    const gCtx = gCvs.getContext('2d');
    const gd = gCtx.createImageData(128, 128);
    for (let i = 0; i < gd.data.length; i += 4) {
      const v = Math.random() * 255;
      gd.data[i] = gd.data[i+1] = gd.data[i+2] = v;
      gd.data[i+3] = 14;
    }
    gCtx.putImageData(gd, 0, 0);
    document.getElementById('grain').style.backgroundImage = `url(${gCvs.toDataURL()})`;

    /* ────────── sky / distant lights ────────── */
    const HORIZON = 0.38; /* 38% from top */

    /* distant lights above horizon (will be reflected below) */
    const lights = [];
    for (let i = 0; i < 24; i++) {
      lights.push({
        x: 0.08 + Math.random() * 0.84,
        y: 0.05 + Math.random() * (HORIZON - 0.12),
        radius: 0.8 + Math.random() * 2.4,
        hue: Math.random() < 0.7 ? 
          210 + Math.random() * 40 : /* blue-cyan */
          Math.random() < 0.5 ? 
            270 + Math.random() * 30 : /* purple */
            180 + Math.random() * 25,  /* teal */
        alpha: 0.015 + Math.random() * 0.035,
        phase: Math.random() * Math.PI * 2,
        freq: 0.0002 + Math.random() * 0.0004
      });
    }

    /* a few warmer accents */
    for (let i = 0; i < 4; i++) {
      lights.push({
        x: 0.15 + Math.random() * 0.7,
        y: 0.08 + Math.random() * (HORIZON - 0.15),
        radius: 1.2 + Math.random() * 1.8,
        hue: 35 + Math.random() * 25, /* warm amber */
        alpha: 0.012 + Math.random() * 0.018,
        phase: Math.random() * Math.PI * 2,
        freq: 0.00015 + Math.random() * 0.00025
      });
    }

    /* ────────── ripples ────────── */
    const ripples = [];
    let nextRipple = 2000;

    function spawnRipple(t) {
      /* ripples originate below horizon (on the water surface) */
      ripples.push({
        x: 0.2 + Math.random() * 0.6,
        y: HORIZON + 0.05 + Math.random() * 0.4,
        born: t,
        maxRadius: 60 + Math.random() * 140,
        duration: 8000 + Math.random() * 6000,
        thickness: 0.5 + Math.random() * 0.8
      });
      nextRipple = t + 3000 + Math.random() * 7000;
    }

    /* ────────── rendering ────────── */
    function drawSky(t) {
      /* gradient sky - deep blue black */
      const skyGrad = ctx.createLinearGradient(0, 0, 0, H * HORIZON);
      skyGrad.addColorStop(0, '#030508');
      skyGrad.addColorStop(0.4, '#060a12');
      skyGrad.addColorStop(0.8, '#0a0f1a');
      skyGrad.addColorStop(1, '#0d1320');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, W, H * HORIZON);

      /* lights in sky */
      for (const l of lights) {
        const breathe = Math.sin(t * l.freq + l.phase) * 0.3 + 0.7;
        const px = l.x * W;
        const py = l.y * H;
        const r = l.radius * 12;

        const grad = ctx.createRadialGradient(px, py, 0, px, py, r);
        grad.addColorStop(0, `hsla(${l.hue}, 50%, 60%, ${l.alpha * breathe})`);
        grad.addColorStop(0.4, `hsla(${l.hue}, 45%, 45%, ${l.alpha * breathe * 0.5})`);
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.fillRect(px - r, py - r, r * 2, r * 2);
      }
    }

    function drawWater(t) {
      const waterTop = H * HORIZON;

      /* base water gradient - darker, deeper */
      const waterGrad = ctx.createLinearGradient(0, waterTop, 0, H);
      waterGrad.addColorStop(0, '#0b1018');
      waterGrad.addColorStop(0.3, '#070b12');
      waterGrad.addColorStop(1, '#040609');
      ctx.fillStyle = waterGrad;
      ctx.fillRect(0, waterTop, W, H - waterTop);

      /* reflections of lights - inverted, stretched, softened */
      for (const l of lights) {
        const breathe = Math.sin(t * l.freq + l.phase) * 0.3 + 0.7;
        const px = l.x * W;
        
        /* reflection y position - mirror across horizon, stretch downward */
        const distFromHorizon = (HORIZON - l.y) * H;
        const reflectY = waterTop + distFromHorizon * 0.7;
        
        /* subtle horizontal shimmer */
        const shimmer = Math.sin(t * 0.0008 + l.x * 10) * 3;
        
        /* vertical stretch for reflection */
        const stretchY = 2.5 + Math.sin(t * 0.0003 + l.phase) * 0.5;
        
        const r = l.radius * 8;
        const rY = r * stretchY;
        
        /* dimmer than source, more diffuse */
        const reflectAlpha = l.alpha * 0.4 * breathe;
        
        ctx.save();
        ctx.translate(px + shimmer, reflectY);
        ctx.scale(1, stretchY);
        
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
        grad.addColorStop(0, `hsla(${l.hue}, 40%, 50%, ${reflectAlpha})`);
        grad.addColorStop(0.5, `hsla(${l.hue}, 35%, 40%, ${reflectAlpha * 0.4})`);
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.fillRect(-r, -r, r * 2, r * 2);
        ctx.restore();
        
        /* vertical light column reflection */
        const columnGrad = ctx.createLinearGradient(px + shimmer, reflectY, px + shimmer, H);
        columnGrad.addColorStop(0, `hsla(${l.hue}, 35%, 45%, ${reflectAlpha * 0.15})`);
        columnGrad.addColorStop(0.5, `hsla(${l.hue}, 30%, 35%, ${reflectAlpha * 0.05})`);
        columnGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = columnGrad;
        ctx.fillRect(px + shimmer - l.radius * 2, reflectY, l.radius * 4, H - reflectY);
      }
    }

    function drawRipples(t) {
      const waterTop = H * HORIZON;
      
      /* spawn new ripple occasionally */
      if (t > nextRipple && ripples.length < 5) spawnRipple(t);

      for (let i = ripples.length - 1; i >= 0; i--) {
        const rip = ripples[i];
        const age = t - rip.born;
        const progress = age / rip.duration;

        if (progress > 1) {
          ripples.splice(i, 1);
          continue;
        }

        const radius = rip.maxRadius * Math.pow(progress, 0.5); /* slow expansion */
        const fade = progress < 0.1 ? progress / 0.1 :
                     Math.pow(1 - progress, 2); /* fade out slowly */

        const cx = rip.x * W;
        const cy = rip.y * H;

        /* elliptical ripple - compressed vertically for perspective */
        const perspectiveY = 0.3 + (cy - waterTop) / (H - waterTop) * 0.4;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(1, perspectiveY);

        /* multiple rings per ripple */
        for (let ring = 0; ring < 3; ring++) {
          const ringRadius = radius * (1 - ring * 0.25);
          if (ringRadius < 2) continue;

          const ringAlpha = fade * 0.04 * (1 - ring * 0.3);

          ctx.beginPath();
          ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(120, 150, 200, ${ringAlpha})`;
          ctx.lineWidth = rip.thickness * (1 - ring * 0.2);
          ctx.stroke();
        }

        ctx.restore();
      }
    }

    /* subtle surface shimmer - very faint noise */
    function drawShimmer(t) {
      const waterTop = H * HORIZON;
      
      ctx.save();
      ctx.globalAlpha = 0.008;
      
      for (let i = 0; i < 40; i++) {
        const x = (Math.sin(t * 0.0001 * (i + 1) + i * 2.3) * 0.5 + 0.5) * W;
        const y = waterTop + (Math.cos(t * 0.00008 * (i + 1) + i * 1.7) * 0.5 + 0.5) * (H - waterTop) * 0.8;
        
        const grad = ctx.createRadialGradient(x, y, 0, x, y, 30);
        grad.addColorStop(0, 'rgba(140, 170, 210, 0.5)');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.fillRect(x - 30, y - 30, 60, 60);
      }
      
      ctx.restore();
    }

    /* ────────── main loop ────────── */
    function frame(t) {
      /* clear */
      ctx.fillStyle = '#040609';
      ctx.fillRect(0, 0, W, H);

      drawSky(t);
      drawWater(t);
      drawShimmer(t);
      drawRipples(t);

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
  </script>
</body>
</html>
