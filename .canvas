<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #060507; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let w, h;
const resize = () => {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
};
resize();
window.addEventListener('resize', resize);

// palette: deep purple, hot pink, electric cyan
const colors = [
  { r: 138, g: 43, b: 226 },   // purple
  { r: 255, g: 20, b: 147 },   // hot pink
  { r: 0, g: 255, b: 255 },    // cyan
  { r: 180, g: 0, b: 180 },    // magenta
];

class Ghost {
  constructor() {
    this.reset();
  }
  
  reset() {
    this.x = Math.random() * w;
    this.y = Math.random() * h;
    this.size = Math.random() * 3 + 1;
    this.color = colors[Math.floor(Math.random() * colors.length)];
    this.alpha = Math.random() * 0.5 + 0.3;
    this.vx = (Math.random() - 0.5) * 0.5;
    this.vy = (Math.random() - 0.5) * 0.5 - 0.3;
    this.life = 1;
    this.decay = Math.random() * 0.002 + 0.001;
    this.pulse = Math.random() * Math.PI * 2;
    this.pulseSpeed = Math.random() * 0.05 + 0.02;
    this.trail = [];
  }
  
  update(time) {
    // flow field influence
    const angle = Math.sin(this.x * 0.005 + time * 0.0003) * 
                  Math.cos(this.y * 0.005 + time * 0.0002) * Math.PI;
    this.vx += Math.cos(angle) * 0.01;
    this.vy += Math.sin(angle) * 0.01;
    
    // drift
    this.vx *= 0.99;
    this.vy *= 0.99;
    
    this.trail.push({ x: this.x, y: this.y, alpha: this.alpha * this.life });
    if (this.trail.length > 20) this.trail.shift();
    
    this.x += this.vx;
    this.y += this.vy;
    
    this.pulse += this.pulseSpeed;
    this.life -= this.decay;
    
    if (this.life <= 0 || this.x < -50 || this.x > w + 50 || this.y < -50 || this.y > h + 50) {
      this.reset();
    }
  }
  
  draw() {
    const pulseAlpha = (Math.sin(this.pulse) * 0.3 + 0.7) * this.life;
    const { r, g, b } = this.color;
    
    // trail
    for (let i = 0; i < this.trail.length; i++) {
      const t = this.trail[i];
      const trailAlpha = (i / this.trail.length) * t.alpha * 0.3;
      ctx.beginPath();
      ctx.arc(t.x, t.y, this.size * 0.5, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${trailAlpha})`;
      ctx.fill();
    }
    
    // glow
    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 8);
    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${pulseAlpha * this.alpha * 0.5})`);
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * 8, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();
    
    // core
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${pulseAlpha * this.alpha})`;
    ctx.fill();
    
    // bright center
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * 0.4, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255, 255, 255, ${pulseAlpha * this.alpha * 0.7})`;
    ctx.fill();
  }
}

// skulls that form from particles
class Skull {
  constructor() {
    this.reset();
  }
  
  reset() {
    this.x = Math.random() * w;
    this.y = Math.random() * h;
    this.size = Math.random() * 15 + 10;
    this.color = colors[Math.floor(Math.random() * colors.length)];
    this.alpha = 0;
    this.maxAlpha = Math.random() * 0.15 + 0.05;
    this.phase = 'in';
    this.speed = Math.random() * 0.005 + 0.002;
    this.rotation = Math.random() * Math.PI * 2;
    this.rotSpeed = (Math.random() - 0.5) * 0.01;
  }
  
  update() {
    if (this.phase === 'in') {
      this.alpha += this.speed;
      if (this.alpha >= this.maxAlpha) this.phase = 'hold';
    } else if (this.phase === 'hold') {
      if (Math.random() < 0.005) this.phase = 'out';
    } else {
      this.alpha -= this.speed;
      if (this.alpha <= 0) this.reset();
    }
    this.rotation += this.rotSpeed;
    this.y -= 0.2;
    if (this.y < -this.size * 2) this.reset();
  }
  
  draw() {
    const { r, g, b } = this.color;
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    ctx.globalAlpha = this.alpha;
    
    // skull shape - simplified cute skull
    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
    
    // head
    ctx.beginPath();
    ctx.ellipse(0, 0, this.size, this.size * 0.9, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // eyes
    ctx.fillStyle = '#060507';
    ctx.beginPath();
    ctx.ellipse(-this.size * 0.35, -this.size * 0.1, this.size * 0.2, this.size * 0.25, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(this.size * 0.35, -this.size * 0.1, this.size * 0.2, this.size * 0.25, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // nose
    ctx.beginPath();
    ctx.moveTo(0, this.size * 0.15);
    ctx.lineTo(-this.size * 0.1, this.size * 0.35);
    ctx.lineTo(this.size * 0.1, this.size * 0.35);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
  }
}

const ghosts = Array.from({ length: 150 }, () => new Ghost());
const skulls = Array.from({ length: 8 }, () => new Skull());

let time = 0;

function animate() {
  time++;
  
  // fade effect
  ctx.fillStyle = 'rgba(6, 5, 7, 0.08)';
  ctx.fillRect(0, 0, w, h);
  
  // update and draw
  for (const skull of skulls) {
    skull.update();
    skull.draw();
  }
  
  for (const ghost of ghosts) {
    ghost.update(time);
    ghost.draw();
  }
  
  // occasional bright flicker
  if (Math.random() < 0.003) {
    const color = colors[Math.floor(Math.random() * colors.length)];
    ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.02)`;
    ctx.fillRect(0, 0, w, h);
  }
  
  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
