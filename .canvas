<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>First Morning</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fraunces:ital,opsz,wght@0,9..144,100;0,9..144,300;1,9..144,200&family=Azeret+Mono:wght@200;300&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%; height: 100%;
      background: #0c0a10;
      overflow: hidden;
      cursor: default;
    }

    canvas { position: fixed; inset: 0; z-index: 1; }

    /* Ghost date — massive, structural */
    .ghost-date {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -55%);
      z-index: 2;
      pointer-events: none;
      font-family: 'Fraunces', serif;
      font-weight: 100;
      font-size: clamp(10rem, 28vmin, 20rem);
      color: rgba(255, 190, 120, 0.012);
      letter-spacing: -0.04em;
      line-height: 0.85;
      user-select: none;
      animation: ghost-breathe 20s ease-in-out infinite;
    }

    /* Bottom text */
    .text-layer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 10;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-bottom: 9%;
      gap: 0.6em;
    }

    .month-label {
      font-family: 'Fraunces', serif;
      font-weight: 200;
      font-style: italic;
      font-size: clamp(0.6rem, 1.3vmin, 0.9rem);
      letter-spacing: 0.45em;
      text-transform: lowercase;
      color: rgba(255, 185, 120, 0.05);
      animation: text-breathe 14s ease-in-out infinite;
    }

    .sub-label {
      font-family: 'Azeret Mono', monospace;
      font-weight: 200;
      font-size: clamp(0.38rem, 0.7vmin, 0.52rem);
      letter-spacing: 0.6em;
      text-transform: uppercase;
      color: rgba(180, 160, 200, 0.03);
      animation: text-breathe 14s ease-in-out infinite 3s;
    }

    @keyframes ghost-breathe {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    @keyframes text-breathe {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    /* Film grain */
    .grain {
      position: fixed; inset: 0;
      pointer-events: none;
      z-index: 90;
      mix-blend-mode: overlay;
      opacity: 0.18;
    }
    .grain svg { width: 100%; height: 100%; display: block; }
  </style>
</head>
<body>

  <canvas id="field"></canvas>

  <div class="ghost-date">01</div>

  <div class="text-layer">
    <div class="month-label">february</div>
    <div class="sub-label">first morning</div>
  </div>

  <div class="grain">
    <svg xmlns="http://www.w3.org/2000/svg">
      <filter id="g">
        <feTurbulence type="fractalNoise" baseFrequency="0.6" numOctaves="4" stitchTiles="stitch"/>
        <feColorMatrix type="saturate" values="0"/>
      </filter>
      <rect width="100%" height="100%" filter="url(#g)" opacity="0.05"/>
    </svg>
  </div>

  <script>
    const canvas = document.getElementById('field');
    const ctx = canvas.getContext('2d');
    let W, H;

    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', () => { resize(); initNodes(); });

    // === COLOR: cool periphery → warm center ===
    function colorForPosition(x, y) {
      const cx = W * 0.48, cy = H * 0.52;
      const dist = Math.hypot(x - cx, y - cy);
      const maxDist = Math.hypot(cx, cy);
      const t = Math.min(1, dist / (maxDist * 0.75));
      // center: warm amber (h:32) → edge: cool indigo (h:245)
      const h = 32 + t * 213;
      const s = 55 + t * 25;
      const l = 58 - t * 18;
      return { h: h % 360, s, l };
    }

    // === NODES ===
    const NODE_COUNT = 38;
    const CONNECT_DIST = 165;
    let nodes = [], edges = [];

    function initNodes() {
      nodes = [];
      edges = [];

      // Poisson-disc-ish placement
      for (let i = 0; i < NODE_COUNT; i++) {
        let x, y, ok, attempts = 0;
        do {
          x = 55 + Math.random() * (W - 110);
          y = 55 + Math.random() * (H - 110);
          ok = nodes.every(n => Math.hypot(x - n.bx, y - n.by) > 50);
          attempts++;
        } while (!ok && attempts < 60);

        const col = colorForPosition(x, y);
        nodes.push({
          bx: x, by: y, x, y,
          r: 1.2 + Math.random() * 2.2,
          col,
          phase: Math.random() * Math.PI * 2,
          pSpeed: 0.0008 + Math.random() * 0.0018,
          dPhase: Math.random() * Math.PI * 2,
          dSpeed: 0.00025 + Math.random() * 0.00035,
          dRadius: 4 + Math.random() * 12,
          bloom: 0,
          baseA: 0.25 + Math.random() * 0.35,
        });
      }

      // Build edges
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const d = Math.hypot(nodes[i].bx - nodes[j].bx, nodes[i].by - nodes[j].by);
          if (d < CONNECT_DIST) edges.push({ a: i, b: j, d });
        }
      }
    }
    initNodes();

    // === SIGNALS ===
    const signals = [];
    let sigTimer = 0;
    const SIG_INTERVAL = 90;

    function spawnSignal() {
      if (!edges.length) return;
      const e = edges[Math.floor(Math.random() * edges.length)];
      const fwd = Math.random() > 0.5;
      signals.push({
        edge: e,
        from: fwd ? e.a : e.b,
        to: fwd ? e.b : e.a,
        t: 0,
        speed: 0.006 + Math.random() * 0.014,
      });
    }

    // === DUST ===
    const DUST = 35;
    const dust = Array.from({ length: DUST }, () => ({
      x: Math.random() * (W || 800),
      y: Math.random() * (H || 600),
      r: Math.random() * 0.9 + 0.15,
      vx: (Math.random() - 0.5) * 0.07,
      vy: -Math.random() * 0.035 - 0.008,
      a: Math.random() * 0.09 + 0.015,
      ph: Math.random() * Math.PI * 2,
    }));

    // === RENDER ===
    function frame(ts) {
      // Background
      const bg = ctx.createRadialGradient(
        W * 0.48, H * 0.52, 0,
        W * 0.48, H * 0.52, Math.max(W, H) * 0.72
      );
      bg.addColorStop(0, '#110f18');
      bg.addColorStop(0.4, '#0d0b14');
      bg.addColorStop(1, '#08070d');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, W, H);

      // Warm center wash
      const warm = ctx.createRadialGradient(
        W * 0.46, H * 0.50, 0,
        W * 0.46, H * 0.50, Math.min(W, H) * 0.5
      );
      warm.addColorStop(0, 'rgba(255, 150, 55, 0.014)');
      warm.addColorStop(0.35, 'rgba(255, 110, 70, 0.005)');
      warm.addColorStop(1, 'transparent');
      ctx.fillStyle = warm;
      ctx.fillRect(0, 0, W, H);

      // Cool top-right accent
      const cool = ctx.createRadialGradient(
        W * 0.82, H * 0.18, 0,
        W * 0.82, H * 0.18, Math.min(W, H) * 0.4
      );
      cool.addColorStop(0, 'rgba(100, 80, 200, 0.008)');
      cool.addColorStop(1, 'transparent');
      ctx.fillStyle = cool;
      ctx.fillRect(0, 0, W, H);

      // Update nodes
      for (const n of nodes) {
        n.x = n.bx + Math.sin(ts * n.dSpeed + n.dPhase) * n.dRadius;
        n.y = n.by + Math.cos(ts * n.dSpeed * 0.7 + n.dPhase * 1.3) * n.dRadius * 0.6;
        n.bloom *= 0.965;
      }

      // Draw edges
      for (const e of edges) {
        const a = nodes[e.a], b = nodes[e.b];
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        const ea = (a.baseA + b.baseA) * 0.5 * 0.03;
        ctx.strokeStyle = `rgba(170, 155, 190, ${ea})`;
        ctx.lineWidth = 0.35;
        ctx.stroke();
      }

      // Spawn & update signals
      sigTimer++;
      if (sigTimer >= SIG_INTERVAL) { spawnSignal(); sigTimer = 0; }

      for (let i = signals.length - 1; i >= 0; i--) {
        const s = signals[i];
        s.t += s.speed;

        if (s.t >= 1) {
          nodes[s.to].bloom = 1;
          signals.splice(i, 1);
          continue;
        }

        const fa = nodes[s.from], ta = nodes[s.to];
        const sx = fa.x + (ta.x - fa.x) * s.t;
        const sy = fa.y + (ta.y - fa.y) * s.t;
        const sa = Math.sin(s.t * Math.PI);

        // Signal glow
        const sg = ctx.createRadialGradient(sx, sy, 0, sx, sy, 14);
        sg.addColorStop(0, `rgba(255, 205, 130, ${sa * 0.45})`);
        sg.addColorStop(0.35, `rgba(255, 175, 95, ${sa * 0.1})`);
        sg.addColorStop(1, 'transparent');
        ctx.fillStyle = sg;
        ctx.fillRect(sx - 18, sy - 18, 36, 36);

        // Signal core
        ctx.beginPath();
        ctx.arc(sx, sy, 1.6, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 235, 195, ${sa * 0.65})`;
        ctx.fill();

        // Trail
        const tLen = 0.12;
        const ts0 = Math.max(0, s.t - tLen);
        const tx = fa.x + (ta.x - fa.x) * ts0;
        const ty = fa.y + (ta.y - fa.y) * ts0;
        ctx.beginPath();
        ctx.moveTo(tx, ty);
        ctx.lineTo(sx, sy);
        ctx.strokeStyle = `rgba(255, 195, 120, ${sa * 0.1})`;
        ctx.lineWidth = 0.7;
        ctx.stroke();
      }

      // Draw nodes
      for (const n of nodes) {
        const pulse = Math.sin(ts * n.pSpeed + n.phase) * 0.5 + 0.5;
        const alpha = n.baseA * (0.35 + pulse * 0.65) + n.bloom * 0.55;
        const size = n.r * (1 + n.bloom * 1.8);

        // Node glow
        const bH = n.bloom > 0.15 ? 34 : n.col.h;
        const bS = n.bloom > 0.15 ? 75 : n.col.s;
        const bL = n.col.l + n.bloom * 28;

        const ng = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, size * 7);
        ng.addColorStop(0, `hsla(${bH}, ${bS}%, ${bL}%, ${alpha * 0.18})`);
        ng.addColorStop(0.35, `hsla(${bH}, ${bS}%, ${bL - 10}%, ${alpha * 0.04})`);
        ng.addColorStop(1, 'transparent');
        ctx.fillStyle = ng;
        ctx.beginPath();
        ctx.arc(n.x, n.y, size * 7, 0, Math.PI * 2);
        ctx.fill();

        // Node core
        ctx.beginPath();
        ctx.arc(n.x, n.y, size, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${bH}, ${bS}%, ${Math.min(88, bL + 14)}%, ${alpha})`;
        ctx.fill();
      }

      // Dust
      for (const d of dust) {
        d.x += d.vx + Math.sin(ts * 0.0003 + d.ph) * 0.015;
        d.y += d.vy;
        d.ph += 0.0015;
        if (d.y < -10) { d.y = H + 10; d.x = Math.random() * W; }
        if (d.x < -10) d.x = W + 10;
        if (d.x > W + 10) d.x = -10;

        ctx.beginPath();
        ctx.arc(d.x, d.y, d.r, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(200, 185, 215, ${d.a * (0.4 + 0.6 * Math.sin(d.ph))})`;
        ctx.fill();
      }

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
  </script>
</body>
</html>
